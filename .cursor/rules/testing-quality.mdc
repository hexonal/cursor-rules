---
description: 
globs: 
alwaysApply: false
---
# å°ç¨‹åºæµ‹è¯•ä¸è´¨é‡ä¿è¯è§„åˆ™

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•è§„èŒƒ
```javascript
// ä½¿ç”¨Jestè¿›è¡Œå°ç¨‹åºç»„ä»¶æµ‹è¯•
describe('MessageInput Component', () => {
  let component;
  
  beforeEach(() => {
    component = {
      data: {
        messageList: [],
        inputValue: '',
        isRecording: false,
      },
      setData: jest.fn(),
      triggerEvent: jest.fn(),
    };
  });

  describe('æ¶ˆæ¯å‘é€åŠŸèƒ½', () => {
    test('åº”è¯¥èƒ½å‘é€æ–‡æœ¬æ¶ˆæ¯', () => {
      const mockMessage = 'æµ‹è¯•æ¶ˆæ¯';
      component.data.inputValue = mockMessage;
      
      // æ¨¡æ‹Ÿå‘é€æ¶ˆæ¯æ–¹æ³•
      const sendMessage = (content) => {
        if (!content.trim()) {
          throw new Error('æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º');
        }
        return { success: true, messageId: '123' };
      };

      const result = sendMessage(component.data.inputValue);
      expect(result.success).toBe(true);
      expect(result.messageId).toBeDefined();
    });

    test('ç©ºæ¶ˆæ¯åº”è¯¥æŠ›å‡ºé”™è¯¯', () => {
      const sendMessage = (content) => {
        if (!content.trim()) {
          throw new Error('æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º');
        }
        return { success: true };
      };

      expect(() => sendMessage('')).toThrow('æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º');
      expect(() => sendMessage('   ')).toThrow('æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º');
    });

    test('é•¿æ¶ˆæ¯åº”è¯¥è¢«æˆªæ–­', () => {
      const MAX_LENGTH = 500;
      const longMessage = 'a'.repeat(600);
      
      const validateMessage = (content) => {
        return content.length > MAX_LENGTH 
          ? content.substring(0, MAX_LENGTH) 
          : content;
      };

      const result = validateMessage(longMessage);
      expect(result.length).toBe(MAX_LENGTH);
    });
  });

  describe('å½•éŸ³åŠŸèƒ½', () => {
    test('åº”è¯¥æ­£ç¡®å¤„ç†å½•éŸ³æƒé™', async () => {
      const mockWx = {
        getSetting: jest.fn(),
        authorize: jest.fn(),
      };

      global.wx = mockWx;

      mockWx.getSetting.mockImplementation(({ success }) => {
        success({ authSetting: { 'scope.record': true } });
      });

      const checkRecordPermission = () => {
        return new Promise((resolve) => {
          wx.getSetting({
            success: (res) => {
              resolve(res.authSetting['scope.record'] !== false);
            },
          });
        });
      };

      const hasPermission = await checkRecordPermission();
      expect(hasPermission).toBe(true);
    });
  });
});
```

### é›†æˆæµ‹è¯•
```javascript
// æµ‹è¯•ç»„ä»¶é—´äº¤äº’
describe('Chat Integration', () => {
  test('æ¶ˆæ¯å‘é€åˆ°åˆ—è¡¨æ˜¾ç¤ºçš„å®Œæ•´æµç¨‹', async () => {
    const mockConversation = {
      conversationID: 'test-conversation',
      type: 'C2C',
    };

    const messageInput = createComponent('MessageInput', {
      conversation: mockConversation,
    });

    const messageList = createComponent('MessageList', {
      conversation: mockConversation,
    });

    // æ¨¡æ‹Ÿå‘é€æ¶ˆæ¯
    await messageInput.sendTextMessage('æµ‹è¯•æ¶ˆæ¯');

    // éªŒè¯æ¶ˆæ¯æ˜¯å¦å‡ºç°åœ¨åˆ—è¡¨ä¸­
    expect(messageList.data.messageList).toContainEqual(
      expect.objectContaining({
        content: 'æµ‹è¯•æ¶ˆæ¯',
        conversationID: mockConversation.conversationID,
      })
    );
  });
});
```

## ğŸ” ä»£ç è´¨é‡æ£€æŸ¥

### ESLinté…ç½®
```javascript
// .eslintrc.js
module.exports = {
  env: {
    es6: true,
    node: true,
  },
  extends: [
    'eslint:recommended',
  ],
  parserOptions: {
    ecmaVersion: 2020,
    sourceType: 'module',
  },
  globals: {
    wx: 'readonly',
    getApp: 'readonly',
    Component: 'readonly',
    Page: 'readonly',
  },
  rules: {
    // ä»£ç é£æ ¼
    'indent': ['error', 2],
    'quotes': ['error', 'single'],
    'semi': ['error', 'always'],
    'comma-dangle': ['error', 'always-multiline'],
    
    // æœ€ä½³å®è·µ
    'no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    'no-console': ['warn'],
    'prefer-const': ['error'],
    'no-var': ['error'],
    
    // å°ç¨‹åºç‰¹å®šè§„åˆ™
    'no-undef': ['error', { typeof: false }],
  },
};
```

### ä»£ç å¤æ‚åº¦æ£€æŸ¥
```javascript
// å¤æ‚åº¦ç›‘æ§å·¥å…·
const CodeComplexityChecker = {
  // æ£€æŸ¥å‡½æ•°å¤æ‚åº¦
  checkFunctionComplexity(functionNode) {
    let complexity = 1; // åŸºç¡€å¤æ‚åº¦
    
    // éå†ASTèŠ‚ç‚¹ï¼Œè®¡ç®—åœˆå¤æ‚åº¦
    const complexityNodes = [
      'IfStatement',
      'SwitchCase', 
      'WhileStatement',
      'ForStatement',
      'ConditionalExpression',
      'LogicalExpression',
    ];

    // é€’å½’è®¡ç®—å¤æ‚åº¦
    function traverse(node) {
      if (complexityNodes.includes(node.type)) {
        complexity++;
      }
      
      if (node.children) {
        node.children.forEach(traverse);
      }
    }

    traverse(functionNode);
    return complexity;
  },

  // æ£€æŸ¥æ–‡ä»¶é•¿åº¦
  checkFileLength(filePath) {
    const fs = require('fs');
    const content = fs.readFileSync(filePath, 'utf8');
    const lines = content.split('\n').length;
    
    if (lines > 500) {
      console.warn(`File ${filePath} is too long (${lines} lines). Consider splitting it.`);
    }
    
    return lines;
  },

  // æ£€æŸ¥æ–¹æ³•æ•°é‡
  checkMethodCount(componentObject) {
    const methodCount = Object.keys(componentObject.methods || {}).length;
    
    if (methodCount > 20) {
      console.warn(`Component has too many methods (${methodCount}). Consider refactoring.`);
    }
    
    return methodCount;
  },
};
```

## ğŸ“Š æ€§èƒ½ç›‘æ§

### æ€§èƒ½æŒ‡æ ‡æ”¶é›†
```javascript
// æ€§èƒ½ç›‘æ§å·¥å…·
const PerformanceMonitor = {
  // ç›‘æ§setDataè°ƒç”¨
  monitorSetData() {
    const originalSetData = Component.prototype.setData;
    
    Component.prototype.setData = function(data, callback) {
      const startTime = Date.now();
      const dataSize = JSON.stringify(data).length;
      
      // æ£€æŸ¥æ•°æ®å¤§å°
      if (dataSize > 1024 * 100) { // 100KB
        console.warn(`Large setData detected: ${dataSize} bytes`, data);
      }
      
      const result = originalSetData.call(this, data, () => {
        const endTime = Date.now();
        const duration = endTime - startTime;
        
        // è®°å½•æ€§èƒ½æ•°æ®
        this._performanceData = this._performanceData || [];
        this._performanceData.push({
          type: 'setData',
          duration,
          dataSize,
          timestamp: startTime,
        });
        
        if (duration > 16) { // è¶…è¿‡ä¸€å¸§æ—¶é—´
          console.warn(`Slow setData detected: ${duration}ms`);
        }
        
        callback && callback();
      });
      
      return result;
    };
  },

  // ç›‘æ§é¡µé¢åŠ è½½æ—¶é—´
  monitorPageLoad() {
    const originalOnLoad = Page.prototype.onLoad;
    
    Page.prototype.onLoad = function(options) {
      const startTime = Date.now();
      
      this.onReady = () => {
        const loadTime = Date.now() - startTime;
        console.log(`Page load time: ${loadTime}ms`);
        
        // ä¸ŠæŠ¥æ€§èƒ½æ•°æ®
        wx.reportAnalytics('page_load_time', {
          page: this.route,
          duration: loadTime,
        });
      };
      
      return originalOnLoad.call(this, options);
    };
  },

  // å†…å­˜ä½¿ç”¨ç›‘æ§
  monitorMemoryUsage() {
    setInterval(() => {
      const memoryInfo = wx.getMemoryInfo && wx.getMemoryInfo();
      if (memoryInfo) {
        console.log('Memory usage:', memoryInfo);
        
        // å†…å­˜ä½¿ç”¨è¿‡é«˜è­¦å‘Š
        if (memoryInfo.usedJSHeapSize / memoryInfo.totalJSHeapSize > 0.8) {
          console.warn('High memory usage detected');
        }
      }
    }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
  },
};
```

### é”™è¯¯ç›‘æ§å’Œä¸ŠæŠ¥
```javascript
// é”™è¯¯ç›‘æ§ç³»ç»Ÿ
const ErrorMonitor = {
  init() {
    // å…¨å±€é”™è¯¯æ•è·
    wx.onError((error) => {
      this.reportError('js_error', error);
    });

    // Promiseé”™è¯¯æ•è·
    wx.onUnhandledRejection((event) => {
      this.reportError('promise_rejection', event.reason);
    });

    // ç»„ä»¶é”™è¯¯è¾¹ç•Œ
    this.setupComponentErrorBoundary();
  },

  reportError(type, error) {
    const errorInfo = {
      type,
      message: error.message || error.toString(),
      stack: error.stack,
      timestamp: Date.now(),
      userAgent: wx.getSystemInfoSync(),
    };

    console.error('Error reported:', errorInfo);

    // ä¸ŠæŠ¥åˆ°ç›‘æ§æœåŠ¡
    wx.request({
      url: 'https://your-monitor-service.com/errors',
      method: 'POST',
      data: errorInfo,
    });
  },

  setupComponentErrorBoundary() {
    const originalComponent = Component;
    
    Component = function(options) {
      // åŒ…è£…methodsä¸­çš„æ¯ä¸ªæ–¹æ³•
      if (options.methods) {
        Object.keys(options.methods).forEach(methodName => {
          const originalMethod = options.methods[methodName];
          
          options.methods[methodName] = function(...args) {
            try {
              return originalMethod.apply(this, args);
            } catch (error) {
              ErrorMonitor.reportError('component_method_error', {
                componentName: this.is,
                methodName,
                error,
              });
              throw error;
            }
          };
        });
      }
      
      return originalComponent(options);
    };
  },
};
```

## ğŸš€ è‡ªåŠ¨åŒ–å·¥å…·

### æ„å»ºæ—¶è´¨é‡æ£€æŸ¥
```javascript
// webpackæ’ä»¶ï¼šæ„å»ºæ—¶è´¨é‡æ£€æŸ¥
class QualityCheckPlugin {
  apply(compiler) {
    compiler.hooks.compilation.tap('QualityCheckPlugin', (compilation) => {
      compilation.hooks.optimizeAssets.tap('QualityCheckPlugin', (assets) => {
        // æ£€æŸ¥åŒ…å¤§å°
        Object.keys(assets).forEach(assetName => {
          const asset = assets[assetName];
          const size = asset.size();
          
          if (size > 1024 * 1024) { // 1MB
            console.warn(`Large asset detected: ${assetName} (${size} bytes)`);
          }
        });

        // æ£€æŸ¥é‡å¤ä»£ç 
        this.checkDuplicateCode(assets);
        
        // æ£€æŸ¥æœªä½¿ç”¨çš„ä»£ç 
        this.checkUnusedCode(assets);
      });
    });
  }

  checkDuplicateCode(assets) {
    // ç®€å•çš„é‡å¤ä»£ç æ£€æµ‹é€»è¾‘
    const codeBlocks = new Map();
    
    Object.values(assets).forEach(asset => {
      const content = asset.source();
      const lines = content.split('\n');
      
      // æ£€æŸ¥é‡å¤çš„ä»£ç å—ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
      for (let i = 0; i < lines.length - 5; i++) {
        const block = lines.slice(i, i + 5).join('\n');
        if (codeBlocks.has(block)) {
          console.warn('Duplicate code block detected');
        } else {
          codeBlocks.set(block, true);
        }
      }
    });
  }

  checkUnusedCode(assets) {
    // æ£€æŸ¥æœªä½¿ç”¨çš„æ–¹æ³•å’Œå˜é‡
    // è¿™é‡Œéœ€è¦ç»“åˆASTåˆ†æå®ç°
    console.log('Checking for unused code...');
  }
}
```

### æŒç»­é›†æˆé…ç½®
```yaml
# .github/workflows/quality-check.yml
name: Quality Check

on: [push, pull_request]

jobs:
  quality:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Setup Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '16'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run ESLint
      run: npm run lint
      
    - name: Run tests
      run: npm test
      
    - name: Check bundle size
      run: npm run build:analyze
      
    - name: SonarCloud Scan
      uses: SonarSource/sonarcloud-github-action@master
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v2
```
