---
description: 
globs: 
alwaysApply: false
---
# å°ç¨‹åºæ€§èƒ½ä¼˜åŒ–è§„åˆ™

## âš¡ æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–

### setData ä¼˜åŒ–ç­–ç•¥
å‚è€ƒ [components/TUIChat/components/MessageInput/index.js](mdc:components/TUIChat/components/MessageInput/index.js) çš„æœ€ä½³å®è·µï¼š

```javascript
// âœ… æ­£ç¡®çš„setDataä½¿ç”¨æ–¹å¼
methods: {
  // 1. æ‰¹é‡æ›´æ–°æ•°æ®ï¼Œå‡å°‘setDataè°ƒç”¨æ¬¡æ•°
  updateMessageState(message) {
    this.setData({
      messageList: [...this.data.messageList, message],
      unreadCount: this.data.unreadCount + 1,
      lastUpdateTime: Date.now(),
    });
  },

  // 2. ä½¿ç”¨å›è°ƒç¡®ä¿æ›´æ–°å®Œæˆåæ‰§è¡Œåç»­é€»è¾‘
  showConversation(conversationID) {
    this.setData({
      isShowConversation: true,
      currentConversationID: conversationID,
    }, () => {
      // ç¡®ä¿DOMæ›´æ–°åå†æ‰§è¡Œ
      const TUIChat = this.selectComponent('#TUIChat');
      TUIChat.init();
    });
  },

  // 3. é¿å…é¢‘ç¹æ›´æ–°ï¼Œä½¿ç”¨é˜²æŠ–
  onInputChange: debounce(function(event) {
    this.setData({
      inputValue: event.detail.value,
    });
  }, 300),
}

// âŒ é”™è¯¯çš„setDataä½¿ç”¨æ–¹å¼
methods: {
  updateMessage(message) {
    // é”™è¯¯ï¼šé¢‘ç¹è°ƒç”¨setData
    this.setData({ messageList: this.data.messageList });
    this.setData({ unreadCount: this.data.unreadCount + 1 });
    this.setData({ lastUpdateTime: Date.now() });
  },
}
```

### é•¿åˆ—è¡¨ä¼˜åŒ–
```javascript
// å‚è€ƒ [components/TUIChat/components/MessageList/index.js](mdc:components/TUIChat/components/MessageList/index.js) è®¾è®¡
Component({
  data: {
    messageList: [],
    virtualListConfig: {
      itemHeight: 80,          // å›ºå®šè¡Œé«˜
      bufferSize: 10,          // ç¼“å†²åŒºå¤§å°
      maxRenderCount: 50,      // æœ€å¤§æ¸²æŸ“æ•°é‡
    },
  },

  methods: {
    // è™šæ‹Ÿåˆ—è¡¨æ¸²æŸ“ä¼˜åŒ–
    updateVirtualList() {
      const { scrollTop, itemHeight, bufferSize } = this.data;
      const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - bufferSize);
      const endIndex = Math.min(
        this.data.messageList.length - 1,
        startIndex + this.data.virtualListConfig.maxRenderCount
      );

      this.setData({
        visibleStartIndex: startIndex,
        visibleEndIndex: endIndex,
        renderList: this.data.messageList.slice(startIndex, endIndex + 1),
      });
    },

    // åˆ†é¡µåŠ è½½å†å²æ¶ˆæ¯
    loadMoreMessages() {
      if (this.data.isLoading || this.data.isCompleted) return;
      
      this.setData({ isLoading: true });
      
      wx.$TUIKit.getMessageList({
        conversationID: this.data.conversation.conversationID,
        nextReqMessageID: this.data.nextReqMessageID,
        count: 15, // åˆ†é¡µå¤§å°æ§åˆ¶
      }).then((res) => {
        const { messageList, nextReqMessageID, isCompleted } = res.data;
        
        this.setData({
          messageList: [...messageList, ...this.data.messageList],
          nextReqMessageID,
          isCompleted,
          isLoading: false,
        });
      });
    },
  },
});
```

### å›¾ç‰‡å’Œåª’ä½“ä¼˜åŒ–
```javascript
// å›¾ç‰‡æ‡’åŠ è½½å’Œå‹ç¼©
methods: {
  handleImageUpload(file) {
    // å›¾ç‰‡å‹ç¼©
    wx.compressImage({
      src: file.path,
      quality: 80,
      success: (res) => {
        this.uploadImage(res.tempFilePath);
      },
    });
  },

  // é¢„åŠ è½½å…³é”®å›¾ç‰‡
  preloadImages() {
    const imageUrls = this.data.messageList
      .filter(msg => msg.type === 'image')
      .map(msg => msg.imageUrl)
      .slice(0, 5); // åªé¢„åŠ è½½å‰5å¼ 

    imageUrls.forEach(url => {
      wx.downloadFile({ url });
    });
  },

  // å›¾ç‰‡æ‡’åŠ è½½
  onImageIntersect(e) {
    const { intersectionRatio, dataset } = e.detail;
    if (intersectionRatio > 0 && dataset.imageUrl) {
      this.loadImage(dataset.imageUrl);
    }
  },
}
```

## ğŸš€ åŒ…ä½“ç§¯ä¼˜åŒ–

### åˆ†åŒ…ç­–ç•¥
```javascript
// app.json åˆ†åŒ…é…ç½®
{
  "pages": [
    "pages/index/index"
  ],
  "subPackages": [
    {
      "root": "packages/chat",
      "name": "chat",
      "pages": [
        "pages/conversation/index",
        "pages/message/index"
      ],
      "independent": false
    },
    {
      "root": "packages/contact", 
      "name": "contact",
      "pages": [
        "pages/list/index",
        "pages/detail/index"
      ],
      "independent": true
    }
  ],
  "preloadRule": {
    "pages/index/index": {
      "network": "all",
      "packages": ["chat"]
    }
  }
}
```

### æŒ‰éœ€åŠ è½½ç»„ä»¶
```javascript
// åŠ¨æ€å¯¼å…¥ç»„ä»¶
methods: {
  async loadChatComponent() {
    // åªæœ‰åœ¨éœ€è¦æ—¶æ‰åŠ è½½èŠå¤©ç»„ä»¶
    if (!this.chatComponentLoaded) {
      const chatModule = await import('../../components/TUIChat/index');
      this.chatComponent = chatModule.default;
      this.chatComponentLoaded = true;
    }
    return this.chatComponent;
  },

  // æ‡’åŠ è½½æ¶ˆæ¯ç±»å‹ç»„ä»¶
  async renderMessage(message) {
    const componentMap = {
      text: () => import('../MessageElements/TextMessage/index'),
      image: () => import('../MessageElements/ImageMessage/index'),
      audio: () => import('../MessageElements/AudioMessage/index'),
    };

    const Component = await componentMap[message.type]();
    return Component.default;
  },
}
```

## ğŸ“± å†…å­˜ç®¡ç†

### äº‹ä»¶ç›‘å¬ç®¡ç†
å‚è€ƒé¡¹ç›®ä¸­çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†æ¨¡å¼ï¼š
```javascript
Component({
  lifetimes: {
    attached() {
      // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
      wx.$TUIKit.on(wx.TencentCloudChat.EVENT.MESSAGE_RECEIVED, this.$onMessageReceived, this);
      wx.$TUIKit.on(wx.TencentCloudChat.EVENT.MESSAGE_REVOKED, this.$onMessageRevoked, this);
      
      // å­˜å‚¨ç›‘å¬å™¨å¼•ç”¨ï¼Œæ–¹ä¾¿æ¸…ç†
      this.listeners = [
        { event: wx.TencentCloudChat.EVENT.MESSAGE_RECEIVED, handler: this.$onMessageReceived },
        { event: wx.TencentCloudChat.EVENT.MESSAGE_REVOKED, handler: this.$onMessageRevoked },
      ];
    },

    detached() {
      // æ¸…ç†æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨
      this.listeners?.forEach(({ event, handler }) => {
        wx.$TUIKit.off(event, handler);
      });
      
      // æ¸…ç†å®šæ—¶å™¨
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      
      // æ¸…ç†å½•éŸ³ç®¡ç†å™¨
      if (this.recorderManager) {
        this.recorderManager.stop();
        this.recorderManager = null;
      }
    },
  },
});
```

### æ•°æ®æ¸…ç†ç­–ç•¥
```javascript
methods: {
  // å®šæœŸæ¸…ç†è¿‡æœŸæ•°æ®
  cleanupExpiredData() {
    const expireTime = Date.now() - 24 * 60 * 60 * 1000; // 24å°æ—¶å‰
    
    const validMessages = this.data.messageList.filter(msg => 
      msg.timestamp > expireTime
    );
    
    if (validMessages.length !== this.data.messageList.length) {
      this.setData({
        messageList: validMessages,
      });
    }
  },

  // æ¸…ç†ç¼“å­˜æ–‡ä»¶
  cleanupCache() {
    wx.getStorageInfo({
      success: (res) => {
        // å¦‚æœç¼“å­˜è¶…è¿‡50MBï¼Œæ¸…ç†æœ€è€çš„æ•°æ®
        if (res.currentSize > 50 * 1024) {
          wx.clearStorage();
        }
      },
    });
  },
}
```

## ğŸŒ ç½‘ç»œä¼˜åŒ–

### è¯·æ±‚ä¼˜åŒ–ç­–ç•¥
```javascript
// è¯·æ±‚å»é‡å’Œç¼“å­˜
const RequestManager = {
  cache: new Map(),
  pendingRequests: new Map(),

  // å¸¦ç¼“å­˜çš„è¯·æ±‚
  async request(url, options = {}) {
    const cacheKey = `${url}${JSON.stringify(options)}`;
    
    // æ£€æŸ¥ç¼“å­˜
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      if (Date.now() - cached.timestamp < 5 * 60 * 1000) { // 5åˆ†é’Ÿç¼“å­˜
        return cached.data;
      }
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒè¯·æ±‚æ­£åœ¨è¿›è¡Œ
    if (this.pendingRequests.has(cacheKey)) {
      return this.pendingRequests.get(cacheKey);
    }

    // å‘èµ·æ–°è¯·æ±‚
    const promise = wx.request({ url, ...options });
    this.pendingRequests.set(cacheKey, promise);

    try {
      const result = await promise;
      this.cache.set(cacheKey, {
        data: result,
        timestamp: Date.now(),
      });
      return result;
    } finally {
      this.pendingRequests.delete(cacheKey);
    }
  },

  // æ‰¹é‡è¯·æ±‚ä¼˜åŒ–
  batchRequest(requests) {
    return Promise.all(
      requests.map(req => this.request(req.url, req.options))
    );
  },
};
```

### ä¸Šä¼ ä¼˜åŒ–
```javascript
methods: {
  // æ–‡ä»¶åˆ†ç‰‡ä¸Šä¼ 
  async uploadLargeFile(file) {
    const chunkSize = 1024 * 1024; // 1MB per chunk
    const chunks = Math.ceil(file.size / chunkSize);
    const uploadPromises = [];

    for (let i = 0; i < chunks; i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, file.size);
      const chunk = file.slice(start, end);
      
      uploadPromises.push(
        this.uploadChunk(chunk, i, chunks, file.name)
      );
    }

    return Promise.all(uploadPromises);
  },

  // å¹¶å‘æ§åˆ¶ä¸Šä¼ 
  async uploadWithConcurrencyLimit(files) {
    const limit = 3; // æœ€å¤§å¹¶å‘æ•°
    const results = [];
    
    for (let i = 0; i < files.length; i += limit) {
      const batch = files.slice(i, i + limit);
      const batchResults = await Promise.all(
        batch.map(file => this.uploadFile(file))
      );
      results.push(...batchResults);
    }
    
    return results;
  },
}
```
