---
description: 
globs: 
alwaysApply: false
---
# å°ç¨‹åºè®¾è®¡æ¨¡å¼åº”ç”¨è§„åˆ™

## ğŸ”„ è§‚å¯Ÿè€…æ¨¡å¼ (Observer Pattern)

### äº‹ä»¶é©±åŠ¨æ¶æ„
åŸºäºé¡¹ç›®ä¸­å¤§é‡ä½¿ç”¨çš„wx.$TUIKitäº‹ä»¶ç³»ç»Ÿå®ç°è§‚å¯Ÿè€…æ¨¡å¼ï¼š

```javascript
// äº‹ä»¶ç®¡ç†å™¨è®¾è®¡
class EventManager {
  constructor() {
    this.events = new Map();
  }

  // è®¢é˜…äº‹ä»¶
  on(eventName, handler, context) {
    if (!this.events.has(eventName)) {
      this.events.set(eventName, []);
    }
    this.events.get(eventName).push({ handler, context });
  }

  // å‘å¸ƒäº‹ä»¶
  emit(eventName, data) {
    const handlers = this.events.get(eventName);
    if (handlers) {
      handlers.forEach(({ handler, context }) => {
        handler.call(context, data);
      });
    }
  }

  // å–æ¶ˆè®¢é˜…
  off(eventName, handler) {
    const handlers = this.events.get(eventName);
    if (handlers) {
      const index = handlers.findIndex(h => h.handler === handler);
      if (index !== -1) {
        handlers.splice(index, 1);
      }
    }
  }
}

// åœ¨ç»„ä»¶ä¸­çš„åº”ç”¨
Component({
  lifetimes: {
    attached() {
      // è®¢é˜…æ¶ˆæ¯ç›¸å…³äº‹ä»¶
      wx.$TUIKit.on(wx.TencentCloudChat.EVENT.MESSAGE_RECEIVED, this.$onMessageReceived, this);
      wx.$TUIKit.on(wx.TencentCloudChat.EVENT.MESSAGE_READ_BY_PEER, this.$onMessageReadByPeer, this);
    },

    detached() {
      // æ¸…ç†äº‹ä»¶ç›‘å¬
      wx.$TUIKit.off(wx.TencentCloudChat.EVENT.MESSAGE_RECEIVED, this.$onMessageReceived);
      wx.$TUIKit.off(wx.TencentCloudChat.EVENT.MESSAGE_READ_BY_PEER, this.$onMessageReadByPeer);
    },
  },

  methods: {
    $onMessageReceived(event) {
      // å¤„ç†æ–°æ¶ˆæ¯
      this.updateMessageList(event.data);
    },

    $onMessageReadByPeer(event) {
      // å¤„ç†æ¶ˆæ¯å·²è¯»çŠ¶æ€
      this.updateReadStatus(event.data);
    },
  },
});
```

## ğŸ­ å·¥å‚æ¨¡å¼ (Factory Pattern)

### æ¶ˆæ¯ç±»å‹å·¥å‚
å‚è€ƒ [components/TUIChat/components/MessageElements](mdc:components/TUIChat/components/MessageElements) çš„è®¾è®¡ï¼š

```javascript
// æ¶ˆæ¯ç»„ä»¶å·¥å‚
class MessageFactory {
  static messageTypes = {
    text: 'TextMessage',
    image: 'ImageMessage', 
    audio: 'AudioMessage',
    video: 'VideoMessage',
    file: 'FileMessage',
    custom: 'CustomMessage',
    system: 'SystemMessage',
  };

  // åˆ›å»ºæ¶ˆæ¯ç»„ä»¶
  static createMessage(messageType, messageData) {
    const ComponentName = this.messageTypes[messageType];
    
    if (!ComponentName) {
      console.warn(`Unknown message type: ${messageType}`);
      return this.createMessage('text', { content: 'ä¸æ”¯æŒçš„æ¶ˆæ¯ç±»å‹' });
    }

    return {
      componentName: ComponentName,
      properties: {
        message: messageData,
        isMine: messageData.flow === 'out',
      },
    };
  }

  // æ³¨å†Œæ–°çš„æ¶ˆæ¯ç±»å‹
  static registerMessageType(type, componentName) {
    this.messageTypes[type] = componentName;
  }
}

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
Component({
  methods: {
    renderMessage(message) {
      const messageComponent = MessageFactory.createMessage(
        message.type, 
        message
      );
      
      this.setData({
        currentMessageComponent: messageComponent,
      });
    },
  },
});
```

### æœåŠ¡å·¥å‚
```javascript
// APIæœåŠ¡å·¥å‚
class ServiceFactory {
  static services = new Map();

  static createService(serviceName, config) {
    if (this.services.has(serviceName)) {
      return this.services.get(serviceName);
    }

    let service;
    switch (serviceName) {
      case 'chat':
        service = new ChatService(config);
        break;
      case 'upload':
        service = new UploadService(config);
        break;
      case 'auth':
        service = new AuthService(config);
        break;
      default:
        throw new Error(`Unknown service: ${serviceName}`);
    }

    this.services.set(serviceName, service);
    return service;
  }

  static getService(serviceName) {
    return this.services.get(serviceName);
  }
}
```

## ğŸ¯ ç­–ç•¥æ¨¡å¼ (Strategy Pattern)

### æ¶ˆæ¯å‘é€ç­–ç•¥
```javascript
// æ¶ˆæ¯å‘é€ç­–ç•¥æ¥å£
class MessageSendStrategy {
  async send(message, options) {
    throw new Error('send method must be implemented');
  }
}

// æ–‡æœ¬æ¶ˆæ¯å‘é€ç­–ç•¥
class TextMessageStrategy extends MessageSendStrategy {
  async send(message, options) {
    return wx.$TUIKit.sendMessage({
      to: options.to,
      conversationType: options.conversationType,
      payload: {
        text: message.content,
      },
    });
  }
}

// å›¾ç‰‡æ¶ˆæ¯å‘é€ç­–ç•¥
class ImageMessageStrategy extends MessageSendStrategy {
  async send(message, options) {
    // å…ˆå‹ç¼©å›¾ç‰‡
    const compressedImage = await this.compressImage(message.file);
    
    return wx.$TUIKit.sendMessage({
      to: options.to,
      conversationType: options.conversationType,
      payload: {
        file: compressedImage,
      },
    });
  }

  async compressImage(file) {
    return new Promise((resolve) => {
      wx.compressImage({
        src: file.path,
        quality: 80,
        success: resolve,
      });
    });
  }
}

// æ¶ˆæ¯å‘é€å™¨
class MessageSender {
  constructor() {
    this.strategies = {
      text: new TextMessageStrategy(),
      image: new ImageMessageStrategy(),
      audio: new AudioMessageStrategy(),
    };
  }

  async sendMessage(message, options) {
    const strategy = this.strategies[message.type];
    if (!strategy) {
      throw new Error(`No strategy for message type: ${message.type}`);
    }
    
    return strategy.send(message, options);
  }
}
```

### æƒé™éªŒè¯ç­–ç•¥
```javascript
// æƒé™éªŒè¯ç­–ç•¥
class PermissionStrategy {
  async checkPermission(permissionType) {
    throw new Error('checkPermission must be implemented');
  }
}

class RecordPermissionStrategy extends PermissionStrategy {
  async checkPermission() {
    return new Promise((resolve) => {
      wx.getSetting({
        success: (res) => {
          const isRecord = res.authSetting['scope.record'];
          if (isRecord === false) {
            // éœ€è¦é‡æ–°æˆæƒ
            wx.authorize({
              scope: 'scope.record',
              success: () => resolve(true),
              fail: () => resolve(false),
            });
          } else {
            resolve(isRecord !== false);
          }
        },
      });
    });
  }
}

class CameraPermissionStrategy extends PermissionStrategy {
  async checkPermission() {
    return new Promise((resolve) => {
      wx.getSetting({
        success: (res) => {
          const hasPermission = res.authSetting['scope.camera'];
          resolve(hasPermission !== false);
        },
      });
    });
  }
}
```

## ğŸ”§ é€‚é…å™¨æ¨¡å¼ (Adapter Pattern)

### SDKé€‚é…å™¨
```javascript
// ç¬¬ä¸‰æ–¹SDKé€‚é…å™¨
class TencentIMAdapter {
  constructor(sdk) {
    this.sdk = sdk;
  }

  // ç»Ÿä¸€çš„æ¶ˆæ¯å‘é€æ¥å£
  async sendMessage(params) {
    const { type, content, to, conversationType } = params;
    
    let message;
    switch (type) {
      case 'text':
        message = this.sdk.createTextMessage({
          to,
          conversationType,
          payload: { text: content },
        });
        break;
      case 'image':
        message = this.sdk.createImageMessage({
          to,
          conversationType,
          payload: { file: content },
        });
        break;
      default:
        throw new Error(`Unsupported message type: ${type}`);
    }

    return this.sdk.sendMessage(message);
  }

  // ç»Ÿä¸€çš„äº‹ä»¶ç›‘å¬æ¥å£
  onMessage(callback) {
    this.sdk.on(this.sdk.EVENT.MESSAGE_RECEIVED, callback);
  }

  offMessage(callback) {
    this.sdk.off(this.sdk.EVENT.MESSAGE_RECEIVED, callback);
  }
}

// ä½¿ç”¨é€‚é…å™¨
const imAdapter = new TencentIMAdapter(wx.$TUIKit);

// ç»Ÿä¸€çš„è°ƒç”¨æ–¹å¼
imAdapter.sendMessage({
  type: 'text',
  content: 'Hello',
  to: 'user123',
  conversationType: 'C2C',
});
```

## ğŸ”— ç»„åˆæ¨¡å¼ (Composite Pattern)

### æ¶ˆæ¯ç»„ä»¶ç»„åˆ
å‚è€ƒé¡¹ç›®ä¸­MessageElementsçš„ç»„åˆè®¾è®¡ï¼š

```javascript
// æ¶ˆæ¯å®¹å™¨ç»„ä»¶
class MessageContainer {
  constructor() {
    this.children = [];
  }

  add(component) {
    this.children.push(component);
  }

  remove(component) {
    const index = this.children.indexOf(component);
    if (index !== -1) {
      this.children.splice(index, 1);
    }
  }

  render() {
    return this.children.map(child => child.render()).join('');
  }
}

// å…·ä½“æ¶ˆæ¯ç»„ä»¶
class TextMessageComponent {
  constructor(data) {
    this.data = data;
  }

  render() {
    return `<text-message message="${this.data}"></text-message>`;
  }
}

class ImageMessageComponent {
  constructor(data) {
    this.data = data;
  }

  render() {
    return `<image-message message="${this.data}"></image-message>`;
  }
}

// ç»„åˆä½¿ç”¨
const messageContainer = new MessageContainer();
messageContainer.add(new TextMessageComponent(textData));
messageContainer.add(new ImageMessageComponent(imageData));
const messageListHTML = messageContainer.render();
```

## ğŸ­ ä»£ç†æ¨¡å¼ (Proxy Pattern)

### ç½‘ç»œè¯·æ±‚ä»£ç†
```javascript
// ç½‘ç»œè¯·æ±‚ä»£ç†ï¼Œæ·»åŠ ç¼“å­˜ã€é‡è¯•ã€é”™è¯¯å¤„ç†
class NetworkProxy {
  constructor() {
    this.cache = new Map();
    this.retryCount = 3;
  }

  async request(url, options = {}) {
    const cacheKey = `${url}_${JSON.stringify(options)}`;
    
    // æ£€æŸ¥ç¼“å­˜
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    // å¸¦é‡è¯•çš„è¯·æ±‚
    let lastError;
    for (let i = 0; i < this.retryCount; i++) {
      try {
        const response = await wx.request({ url, ...options });
        this.cache.set(cacheKey, response);
        return response;
      } catch (error) {
        lastError = error;
        await this.delay(1000 * (i + 1)); // é€’å¢å»¶è¿Ÿ
      }
    }

    throw lastError;
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// ä½¿ç”¨ä»£ç†
const networkProxy = new NetworkProxy();
const result = await networkProxy.request('/api/messages');
```
