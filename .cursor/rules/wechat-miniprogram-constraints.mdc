---
description: 
globs: 
alwaysApply: false
---
# å¾®ä¿¡å°ç¨‹åºå¹³å°çº¦æŸä¸“é—¨è§„åˆ™

## ğŸ“± å¾®ä¿¡å°ç¨‹åºç‹¬æœ‰é™åˆ¶å¤„ç†

### åŒ…ä½“ç§¯2MBé™åˆ¶ä¸“é—¨ä¼˜åŒ–
```javascript
// ä¸“é—¨çš„åˆ†åŒ…ç­–ç•¥ - åŸºäºèŠå¤©åŠŸèƒ½
const ChatPackageStrategy = {
  // ä¸»åŒ…ï¼šæ ¸å¿ƒèŠå¤©åŠŸèƒ½
  mainPackage: {
    maxSize: 1.5 * 1024 * 1024, // 1.5MB
    components: [
      'components/TUIConversation',
      'components/TUIChat/components/MessageList',
      'components/TUIChat/components/MessageInput',
      'components/TUIChat/components/MessageElements/TextMessage',
    ],
  },

  // åˆ†åŒ…1ï¼šåª’ä½“æ¶ˆæ¯ç»„ä»¶
  mediaPackage: {
    root: 'packages/media',
    components: [
      'MessageElements/ImageMessage',
      'MessageElements/AudioMessage', 
      'MessageElements/VideoMessage',
      'MessageElements/FileMessage',
    ],
  },

  // åˆ†åŒ…2ï¼šæ‰©å±•åŠŸèƒ½
  extensionPackage: {
    root: 'packages/extension',
    components: [
      'MessageElements/CustomMessage',
      'MessagePrivate/CommonWords',
      'MessagePrivate/OrderList',
      'TUICallKit',
    ],
  },

  // åŠ¨æ€åŠ è½½ç­–ç•¥
  async loadPackage(packageName) {
    if (this.loadedPackages.has(packageName)) {
      return this.loadedPackages.get(packageName);
    }

    try {
      // æ˜¾ç¤ºåŠ è½½æç¤º
      wx.showLoading({ title: 'åŠ è½½ä¸­...' });
      
      const packageModule = await import(`../packages/${packageName}/index`);
      this.loadedPackages.set(packageName, packageModule);
      
      wx.hideLoading();
      return packageModule;
    } catch (error) {
      wx.hideLoading();
      wx.showToast({ title: 'åŠŸèƒ½åŠ è½½å¤±è´¥', icon: 'none' });
      throw error;
    }
  },
};
```

### å†…å­˜é™åˆ¶ä¸“é—¨ç®¡ç†
```javascript
// é’ˆå¯¹å¾®ä¿¡å°ç¨‹åºå†…å­˜é™åˆ¶çš„ä¸“é—¨ç®¡ç†
const WeChatMemoryManager = {
  // iOS: ä¸åŒæœºå‹å†…å­˜é™åˆ¶ä¸åŒ
  memoryLimits: {
    iPhone6: 320 * 1024 * 1024,    // 320MB
    iPhone7Plus: 512 * 1024 * 1024, // 512MB
    iPhoneX: 1024 * 1024 * 1024,   // 1GB
  },

  currentMemoryUsage: 0,
  maxChatHistory: 200, // æœ€å¤šä¿ç•™200æ¡æ¶ˆæ¯

  // æ£€æµ‹è®¾å¤‡å†…å­˜é™åˆ¶
  detectDeviceMemoryLimit() {
    const systemInfo = wx.getSystemInfoSync();
    const { model, platform } = systemInfo;
    
    if (platform === 'ios') {
      // æ ¹æ®è®¾å¤‡å‹å·ä¼°ç®—å†…å­˜é™åˆ¶
      if (model.includes('iPhone 6')) {
        return this.memoryLimits.iPhone6;
      } else if (model.includes('iPhone 7 Plus')) {
        return this.memoryLimits.iPhone7Plus;
      } else {
        return this.memoryLimits.iPhoneX;
      }
    } else {
      // Androidè®¾å¤‡å·®å¼‚å¾ˆå¤§ï¼Œä½¿ç”¨ä¿å®ˆä¼°è®¡
      return 256 * 1024 * 1024; // 256MB
    }
  },

  // æ™ºèƒ½æ¶ˆæ¯æ¸…ç†
  smartMessageCleanup() {
    const messageList = this.data.messageList;
    
    if (messageList.length > this.maxChatHistory) {
      // ä¿ç•™æœ€æ–°çš„æ¶ˆæ¯ï¼Œæ¸…ç†æ—§æ¶ˆæ¯
      const messagesToKeep = messageList.slice(-this.maxChatHistory);
      const messagesToClean = messageList.slice(0, -this.maxChatHistory);
      
      // æ¸…ç†åª’ä½“æ–‡ä»¶å¼•ç”¨
      this.cleanupMediaReferences(messagesToClean);
      
      this.setData({
        messageList: messagesToKeep,
      });
    }
  },

  // æ¸…ç†åª’ä½“æ–‡ä»¶å¼•ç”¨ï¼Œé‡Šæ”¾å†…å­˜
  cleanupMediaReferences(messages) {
    messages.forEach(message => {
      if (message.type === 'image' && message.localImagePath) {
        // ä¸åˆ é™¤æ–‡ä»¶ï¼Œåªæ¸…ç†å¼•ç”¨
        delete message.localImagePath;
      }
      if (message.type === 'audio' && message.audioContext) {
        // é”€æ¯éŸ³é¢‘ä¸Šä¸‹æ–‡
        message.audioContext.destroy();
        delete message.audioContext;
      }
    });
  },

  // ç›‘æ§å†…å­˜ä½¿ç”¨
  monitorMemoryUsage() {
    // å¾®ä¿¡å°ç¨‹åºæ²¡æœ‰ç›´æ¥çš„å†…å­˜ç›‘æ§APIï¼Œä½¿ç”¨æ•°æ®å¤§å°ä¼°ç®—
    const estimateMemoryUsage = () => {
      const dataSize = JSON.stringify(this.data).length;
      const imageCount = this.data.messageList.filter(msg => msg.type === 'image').length;
      const audioCount = this.data.messageList.filter(msg => msg.type === 'audio').length;
      
      // ä¼°ç®—å†…å­˜ä½¿ç”¨é‡
      return dataSize + imageCount * 1024 * 1024 + audioCount * 512 * 1024;
    };

    setInterval(() => {
      const usage = estimateMemoryUsage();
      const limit = this.detectDeviceMemoryLimit();
      
      if (usage > limit * 0.8) { // è¶…è¿‡80%ä½¿ç”¨ç‡
        console.warn('Memory usage high, triggering cleanup');
        this.smartMessageCleanup();
      }
    }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
  },
};
```

### å¾®ä¿¡å°ç¨‹åºCanvasé™åˆ¶å¤„ç†
```javascript
// Canvasåœ¨èŠå¤©ä¸­çš„ç‰¹æ®Šåº”ç”¨ï¼ˆå¦‚ç»˜ç”»æ¶ˆæ¯ã€å›¾ç‰‡ç¼–è¾‘ï¼‰
const WeChatCanvasManager = {
  maxCanvasSize: {
    width: 750,  // å¾®ä¿¡å°ç¨‹åºCanvasæœ€å¤§å®½åº¦é™åˆ¶
    height: 1334, // æœ€å¤§é«˜åº¦é™åˆ¶
  },

  // å¤„ç†é«˜åˆ†è¾¨ç‡å›¾ç‰‡
  processHighResImage(imagePath) {
    return new Promise((resolve, reject) => {
      wx.getImageInfo({
        src: imagePath,
        success: (res) => {
          const { width, height } = res;
          
          // æ£€æŸ¥æ˜¯å¦è¶…è¿‡Canvasé™åˆ¶
          if (width > this.maxCanvasSize.width || height > this.maxCanvasSize.height) {
            // éœ€è¦å‹ç¼©
            this.compressImageForCanvas(imagePath, width, height)
              .then(resolve)
              .catch(reject);
          } else {
            resolve(imagePath);
          }
        },
        fail: reject,
      });
    });
  },

  async compressImageForCanvas(imagePath, originalWidth, originalHeight) {
    const canvas = wx.createCanvasContext('image-compress-canvas');
    
    // è®¡ç®—å‹ç¼©æ¯”ä¾‹
    const scaleX = this.maxCanvasSize.width / originalWidth;
    const scaleY = this.maxCanvasSize.height / originalHeight;
    const scale = Math.min(scaleX, scaleY, 1); // ä¸æ”¾å¤§
    
    const newWidth = originalWidth * scale;
    const newHeight = originalHeight * scale;
    
    // ç»˜åˆ¶å‹ç¼©åçš„å›¾ç‰‡
    canvas.drawImage(imagePath, 0, 0, newWidth, newHeight);
    
    return new Promise((resolve) => {
      canvas.draw(false, () => {
        wx.canvasToTempFilePath({
          canvasId: 'image-compress-canvas',
          width: newWidth,
          height: newHeight,
          success: (res) => resolve(res.tempFilePath),
        });
      });
    });
  },
};
```

## ğŸ”’ å¾®ä¿¡å°ç¨‹åºæƒé™å¤„ç†

### æ•æ„ŸAPIæƒé™ç®¡ç†
```javascript
// ä¸“é—¨å¤„ç†å¾®ä¿¡å°ç¨‹åºçš„æ•æ„Ÿæƒé™
const WeChatPermissionManager = {
  // æƒé™çŠ¶æ€ç¼“å­˜
  permissionCache: new Map(),

  // ç»Ÿä¸€æƒé™æ£€æŸ¥æµç¨‹
  async checkAndRequestPermission(scopeName, options = {}) {
    const cacheKey = scopeName;
    
    // æ£€æŸ¥ç¼“å­˜
    if (this.permissionCache.has(cacheKey)) {
      const cachedResult = this.permissionCache.get(cacheKey);
      if (Date.now() - cachedResult.timestamp < 60000) { // 1åˆ†é’Ÿç¼“å­˜
        return cachedResult.hasPermission;
      }
    }

    try {
      // æ£€æŸ¥å½“å‰æƒé™çŠ¶æ€
      const settingRes = await this.getSetting();
      const currentPermission = settingRes.authSetting[scopeName];
      
      if (currentPermission === true) {
        this.cachePermission(cacheKey, true);
        return true;
      }
      
      if (currentPermission === false) {
        // ç”¨æˆ·å·²æ‹’ç»ï¼Œéœ€è¦å¼•å¯¼åˆ°è®¾ç½®é¡µ
        return this.guideToSettings(scopeName, options);
      }
      
      // é¦–æ¬¡è¯·æ±‚æƒé™
      return this.requestPermission(scopeName, options);
      
    } catch (error) {
      console.error('Permission check failed:', error);
      return false;
    }
  },

  // å½•éŸ³æƒé™ä¸“é—¨å¤„ç†
  async checkRecordPermission() {
    return this.checkAndRequestPermission('scope.record', {
      title: 'éœ€è¦å½•éŸ³æƒé™',
      content: 'å‘é€è¯­éŸ³æ¶ˆæ¯éœ€è¦å½•éŸ³æƒé™ï¼Œè¯·å…è®¸ä½¿ç”¨éº¦å…‹é£',
      settingsText: 'è¯­éŸ³æ¶ˆæ¯åŠŸèƒ½éœ€è¦å½•éŸ³æƒé™ï¼Œè¯·åœ¨è®¾ç½®ä¸­å¼€å¯',
    });
  },

  // ç›¸æœºæƒé™ä¸“é—¨å¤„ç†
  async checkCameraPermission() {
    return this.checkAndRequestPermission('scope.camera', {
      title: 'éœ€è¦ç›¸æœºæƒé™', 
      content: 'æ‹ç…§å‘é€å›¾ç‰‡éœ€è¦ç›¸æœºæƒé™',
      settingsText: 'æ‹ç…§åŠŸèƒ½éœ€è¦ç›¸æœºæƒé™ï¼Œè¯·åœ¨è®¾ç½®ä¸­å¼€å¯',
    });
  },

  // ç›¸å†Œæƒé™ä¸“é—¨å¤„ç†
  async checkAlbumPermission() {
    return this.checkAndRequestPermission('scope.writePhotosAlbum', {
      title: 'éœ€è¦ç›¸å†Œæƒé™',
      content: 'ä¿å­˜å›¾ç‰‡åˆ°ç›¸å†Œéœ€è¦ç›¸å†Œæƒé™', 
      settingsText: 'ä¿å­˜å›¾ç‰‡åŠŸèƒ½éœ€è¦ç›¸å†Œæƒé™ï¼Œè¯·åœ¨è®¾ç½®ä¸­å¼€å¯',
    });
  },

  // å¼•å¯¼ç”¨æˆ·åˆ°è®¾ç½®é¡µé¢
  guideToSettings(scopeName, options) {
    return new Promise((resolve) => {
      wx.showModal({
        title: options.title || 'æƒé™ç”³è¯·',
        content: options.settingsText || 'éœ€è¦ç›¸å…³æƒé™æ‰èƒ½ä½¿ç”¨è¯¥åŠŸèƒ½ï¼Œè¯·åˆ°è®¾ç½®é¡µé¢å¼€å¯',
        confirmText: 'å»è®¾ç½®',
        cancelText: 'å–æ¶ˆ',
        success: (res) => {
          if (res.confirm) {
            wx.openSetting({
              success: (settingRes) => {
                const hasPermission = settingRes.authSetting[scopeName] === true;
                this.cachePermission(scopeName, hasPermission);
                resolve(hasPermission);
              },
              fail: () => resolve(false),
            });
          } else {
            resolve(false);
          }
        },
      });
    });
  },

  // ç¼“å­˜æƒé™ç»“æœ
  cachePermission(scopeName, hasPermission) {
    this.permissionCache.set(scopeName, {
      hasPermission,
      timestamp: Date.now(),
    });
  },

  // PromiseåŒ–wx.getSetting
  getSetting() {
    return new Promise((resolve, reject) => {
      wx.getSetting({
        success: resolve,
        fail: reject,
      });
    });
  },

  // è¯·æ±‚æƒé™
  requestPermission(scopeName, options) {
    return new Promise((resolve) => {
      wx.authorize({
        scope: scopeName,
        success: () => {
          this.cachePermission(scopeName, true);
          resolve(true);
        },
        fail: () => {
          // ç”¨æˆ·æ‹’ç»ï¼Œå¼•å¯¼åˆ°è®¾ç½®
          this.guideToSettings(scopeName, options).then(resolve);
        },
      });
    });
  },
};
```

## ğŸŒ ç½‘ç»œè¯·æ±‚é™åˆ¶å¤„ç†

### åŸŸåç™½åå•ç®¡ç†
```javascript
// å¾®ä¿¡å°ç¨‹åºåŸŸåç™½åå•ç®¡ç†
const DomainWhitelistManager = {
  // é¢„é…ç½®çš„åŸŸå
  allowedDomains: [
    'https://api.im.qcloud.com',
    'https://cos.ap-guangzhou.myqcloud.com',
    'https://your-chat-api.com',
  ],

  // æ£€æŸ¥URLæ˜¯å¦åœ¨ç™½åå•ä¸­
  isAllowedDomain(url) {
    try {
      const urlObj = new URL(url);
      const domain = `${urlObj.protocol}//${urlObj.host}`;
      
      return this.allowedDomains.some(allowedDomain => 
        domain.startsWith(allowedDomain)
      );
    } catch (error) {
      console.error('Invalid URL:', url);
      return false;
    }
  },

  // å®‰å…¨çš„ç½‘ç»œè¯·æ±‚åŒ…è£…
  async safeRequest(url, options = {}) {
    if (!this.isAllowedDomain(url)) {
      throw new Error(`Domain not allowed: ${url}`);
    }

    return new Promise((resolve, reject) => {
      wx.request({
        url,
        ...options,
        success: resolve,
        fail: reject,
      });
    });
  },

  // æ–‡ä»¶ä¸Šä¼ åŸŸåæ£€æŸ¥
  async safeUploadFile(url, options = {}) {
    if (!this.isAllowedDomain(url)) {
      throw new Error(`Upload domain not allowed: ${url}`);
    }

    return new Promise((resolve, reject) => {
      wx.uploadFile({
        url,
        ...options,
        success: resolve,
        fail: reject,
      });
    });
  },
};
```

### å¹¶å‘è¯·æ±‚é™åˆ¶
```javascript
// å¾®ä¿¡å°ç¨‹åºå¹¶å‘è¯·æ±‚é™åˆ¶ç®¡ç†
const ConcurrentRequestManager = {
  maxConcurrentRequests: 10, // å¾®ä¿¡å°ç¨‹åºæœ€å¤§å¹¶å‘æ•°
  activeRequests: new Set(),
  requestQueue: [],

  async request(url, options = {}) {
    // å¦‚æœè¾¾åˆ°å¹¶å‘é™åˆ¶ï¼ŒåŠ å…¥é˜Ÿåˆ—
    if (this.activeRequests.size >= this.maxConcurrentRequests) {
      return new Promise((resolve, reject) => {
        this.requestQueue.push({
          url,
          options,
          resolve,
          reject,
        });
      });
    }

    return this.executeRequest(url, options);
  },

  async executeRequest(url, options) {
    const requestId = Symbol('request');
    this.activeRequests.add(requestId);

    try {
      const result = await DomainWhitelistManager.safeRequest(url, options);
      return result;
    } finally {
      this.activeRequests.delete(requestId);
      this.processQueue();
    }
  },

  processQueue() {
    if (this.requestQueue.length > 0 && 
        this.activeRequests.size < this.maxConcurrentRequests) {
      
      const { url, options, resolve, reject } = this.requestQueue.shift();
      
      this.executeRequest(url, options)
        .then(resolve)
        .catch(reject);
    }
  },
};
```
