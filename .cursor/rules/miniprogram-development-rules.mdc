---
description: 
globs: 
alwaysApply: false
---
# 微信小程序开发规则

---
## 📋 规则元数据
- **规则类型**: 平台基础规则 (Platform Foundation Rules)
- **作用域**: 微信小程序平台开发
- **自动附加条件**: `*.js`, `*.json`, `*.wxml`, `*.wxss` 文件
- **优先级**: 基础平台规则 (Priority: 100)
- **被引用于**: 其他项目特定规则
- **冲突解决**: 业务特定规则 > 平台基础规则

## 📚 规则引用系统
```markdown
语法: [规则文件](mdc:.cursor/rules/规则文件.mdc)
示例: [编码规范](mdc:.cursor/rules/coding-standards.mdc)
冲突解决: 当前规则优先级 < 引用规则优先级时，引用规则生效
```
---

## 🏗️ 小程序架构设计

> 🔗 **编码规范**: [编码规范详细指南](mdc:.cursor/rules/coding-standards.mdc)  
> 📝 **包含**: 命名约定、代码结构、注释规范、错误处理

### 组件化设计原则
```javascript
// 组件标准结构
Component({
  options: {
    // 组件配置
    multipleSlots: true,
    addGlobalClass: true,
  },
  
  properties: {
    // 对外属性，使用observer监听变化
    data: {
      type: Object,
      value: {},
      observer(newVal, oldVal) {
        this.processDataChange(newVal, oldVal);
      },
    },
  },
  
  data: {
    // 内部状态
    internalState: '',
  },
  
  lifetimes: {
    attached() {
      // 组件初始化
      this.initComponent();
    },
    
    detached() {
      // 资源清理，防止内存泄漏
      this.cleanup();
    },
  },
  
  methods: {
    // 公共方法用$前缀
    $publicMethod() {},
    
    // 事件处理用handle前缀
    handleUserAction() {},
    
    // 内部方法用常规命名
    processData() {},
  },
});
```

### 页面生命周期管理
```javascript
Page({
  data: {
    // 页面数据
  },
  
  onLoad(options) {
    // 页面加载时初始化
    this.initPage(options);
  },
  
  onShow() {
    // 页面显示时的处理
    this.refreshData();
  },
  
  onHide() {
    // 页面隐藏时暂停操作
    this.pauseOperations();
  },
  
  onUnload() {
    // 页面卸载时清理资源
    this.cleanup();
  },
});
```

## ⚡ 性能优化规则 {#性能优化规则}

> 📝 **扩展说明**: 适用于所有需要批量数据更新的场景

### setData优化 {#setData优化}
```javascript
// ✅ 正确的setData使用
methods: {
  // 批量更新数据
  batchUpdate() {
    this.setData({
      'list[0].name': 'new name',
      'list[0].status': 'active',
      updateTime: Date.now(),
    });
  },
  
  // 使用回调确保更新完成
  updateWithCallback() {
    this.setData({
      loading: false,
    }, () => {
      // 数据更新完成后的操作
      this.afterUpdate();
    });
  },
  
  // 避免频繁更新，使用防抖
  onInputChange: throttle(function(e) {
    this.setData({
      inputValue: e.detail.value,
    });
  }, 300),
}

// ❌ 避免的做法
methods: {
  badUpdate() {
    // 避免频繁调用setData
    this.setData({ loading: true });
    this.setData({ data: newData });
    this.setData({ loading: false });
  },
}
```

### 长列表优化 {#长列表优化}

> 📝 **扩展说明**: 适用于所有长列表展示场景，如商品列表、内容列表等

```javascript
// 虚拟列表实现
Component({
  data: {
    visibleStart: 0,
    visibleEnd: 20,
    itemHeight: 100,
    renderList: [],
  },
  
  methods: {
    onScroll(e) {
      const scrollTop = e.detail.scrollTop;
      const containerHeight = this.data.containerHeight;
      
      const visibleStart = Math.floor(scrollTop / this.data.itemHeight);
      const visibleEnd = visibleStart + Math.ceil(containerHeight / this.data.itemHeight) + 1;
      
      this.setData({
        visibleStart,
        visibleEnd,
        renderList: this.data.fullList.slice(visibleStart, visibleEnd),
      });
    },
  },
});
```

## 📱 小程序特有限制处理

### 包体积管理
```javascript
// 分包配置示例
// app.json
{
  "pages": [
    "pages/index/index"
  ],
  "subPackages": [
    {
      "root": "packages/feature-a",
      "pages": [
        "pages/detail/detail"
      ]
    }
  ],
  "preloadRule": {
    "pages/index/index": {
      "network": "all",
      "packages": ["feature-a"]
    }
  }
}

// 动态导入
methods: {
  async loadFeature() {
    try {
      const module = await import('../../packages/feature-a/utils');
      return module.default;
    } catch (error) {
      console.error('Load feature failed:', error);
    }
  },
}
```

### 内存管理 {#内存管理}

> 📝 **扩展说明**: 适用于所有需要缓存管理的场景，如数据缓存、图片缓存等

```javascript
// 内存使用监控
const MemoryManager = {
  maxDataSize: 50 * 1024 * 1024, // 50MB
  
  checkMemoryUsage() {
    // 估算数据大小
    const dataSize = JSON.stringify(getCurrentPageData()).length;
    
    if (dataSize > this.maxDataSize) {
      this.triggerDataCleanup();
    }
  },
  
  triggerDataCleanup() {
    // 清理非必要数据
    wx.getCurrentPages().forEach(page => {
      if (page.cleanup && typeof page.cleanup === 'function') {
        page.cleanup();
      }
    });
  },
};
```

## 🔒 权限管理

### 统一权限处理
```javascript
const PermissionManager = {
  async requestPermission(scope, options = {}) {
    try {
      // 检查当前权限状态
      const setting = await this.getSetting();
      const hasPermission = setting.authSetting[scope];
      
      if (hasPermission === true) {
        return true;
      }
      
      if (hasPermission === false) {
        // 已拒绝，引导到设置页
        return this.openSetting(options);
      }
      
      // 首次申请
      return this.authorize(scope);
      
    } catch (error) {
      console.error('Permission request failed:', error);
      return false;
    }
  },
  
  getSetting() {
    return new Promise((resolve, reject) => {
      wx.getSetting({
        success: resolve,
        fail: reject,
      });
    });
  },
  
  authorize(scope) {
    return new Promise((resolve) => {
      wx.authorize({
        scope,
        success: () => resolve(true),
        fail: () => resolve(false),
      });
    });
  },
  
  openSetting(options) {
    return new Promise((resolve) => {
      wx.showModal({
        title: options.title || '权限申请',
        content: options.content || '需要相关权限才能使用该功能',
        success: (res) => {
          if (res.confirm) {
            wx.openSetting({
              success: () => resolve(true),
              fail: () => resolve(false),
            });
          } else {
            resolve(false);
          }
        },
      });
    });
  },
};
```

## 🌐 网络请求管理

### 请求封装
```javascript
const RequestManager = {
  baseURL: '',
  timeout: 10000,
  maxRetry: 3,
  
  async request(options) {
    const requestOptions = {
      url: this.baseURL + options.url,
      method: options.method || 'GET',
      data: options.data,
      header: {
        'content-type': 'application/json',
        ...options.header,
      },
      timeout: options.timeout || this.timeout,
    };
    
    return this.executeWithRetry(requestOptions, options.retry || this.maxRetry);
  },
  
  async executeWithRetry(options, retryCount) {
    try {
      return await this.executeRequest(options);
    } catch (error) {
      if (retryCount > 0 && this.shouldRetry(error)) {
        await this.delay(1000);
        return this.executeWithRetry(options, retryCount - 1);
      }
      throw error;
    }
  },
  
  executeRequest(options) {
    return new Promise((resolve, reject) => {
      wx.request({
        ...options,
        success: (res) => {
          if (res.statusCode >= 200 && res.statusCode < 300) {
            resolve(res.data);
          } else {
            reject(new Error(`HTTP ${res.statusCode}`));
          }
        },
        fail: reject,
      });
    });
  },
  
  shouldRetry(error) {
    // 网络错误或超时才重试
    return error.errMsg && (
      error.errMsg.includes('timeout') ||
      error.errMsg.includes('fail')
    );
  },
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  },
};
```

## 🛠️ 工具函数规范

### 通用工具
```javascript
// 防抖函数
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// 节流函数
function throttle(func, limit) {
  let inThrottle;
  return function executedFunction(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// 深拷贝
function deepClone(obj) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (obj instanceof Date) return new Date(obj.getTime());
  if (obj instanceof Array) return obj.map(item => deepClone(item));
  if (typeof obj === 'object') {
    const clonedObj = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        clonedObj[key] = deepClone(obj[key]);
      }
    }
    return clonedObj;
  }
}
```

## 📋 代码规范

### 命名约定
- **页面/组件**: PascalCase (UserProfile)
- **方法/变量**: camelCase (getUserInfo)
- **常量**: UPPER_SNAKE_CASE (MAX_RETRY_COUNT)
- **文件名**: kebab-case (user-profile.js)

### 错误处理
```javascript
// 统一错误处理
const ErrorHandler = {
  handle(error, context) {
    console.error(`Error in ${context}:`, error);
    
    // 根据错误类型显示不同提示
    const message = this.getErrorMessage(error);
    wx.showToast({
      title: message,
      icon: 'none',
    });
  },
  
  getErrorMessage(error) {
    const errorMap = {
      'network': '网络连接失败',
      'timeout': '请求超时',
      'permission': '权限不足',
    };
    
    return errorMap[error.type] || '操作失败，请重试';
  },
};
```
