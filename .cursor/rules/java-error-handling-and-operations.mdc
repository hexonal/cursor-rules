---
description: 
globs: 
alwaysApply: true
---
---
description: 
globs: 
alwaysApply: true
---
# Java项目异常处理与操作智能化规范

本规范提供智能化、自适应的异常处理与系统操作设计指导，通过Cursor代码库索引技术，基于项目现有模式提供个性化的异常处理策略。

## 一、智能异常体系分析

### 【项目适配】异常体系结构分析
1. **基于Cursor的异常类型分析**：
   ```
   提示词：@codebase 分析所有异常类，总结项目异常体系结构
   包括：
   - 异常基类（BaseException、BizException等）
   - 自定义异常类的继承关系
   - 异常类的命名规律和包组织方式
   - 错误码枚举的定义和使用模式
   ```

2. **智能错误码体系识别**：
   ```
   提示词：@codebase 分析所有错误码定义，确定项目错误码规范
   分析内容：
   - 错误码枚举类的命名和结构
   - 错误码格式规律（3位数、5位数、字符串等）
   - 错误码分类方式（系统级、业务级、服务级）
   - 错误消息模板的国际化支持情况
   ```

3. **异常处理模式智能识别**：
   ```
   提示词：@codebase 分析Controller层异常处理，总结统一异常处理模式
   检查内容：
   - @RestControllerAdvice的使用情况
   - 异常处理方法的覆盖范围
   - Result响应包装类的使用模式
   - HTTP状态码与业务错误码的映射关系
   ```

### 【项目适配】智能异常处理策略
1. **基于现有模式的异常定义**：
   ```java
   // 第一步：使用Cursor智能分析现有异常类
   // 提示词：@codebase 分析现有BizException和SystemException类的结构和使用方式
   
   // 第二步：按照项目现有模式定义新异常
   // 如果项目已有异常基类，按现有模式扩展
   public class OrderException extends ProjectBizException {
       // 使用项目现有的错误码枚举
       public OrderException(ProjectErrorCode errorCode) {
           super(errorCode);
       }
       
       // 如果项目支持，添加上下文信息
       public OrderException(ProjectErrorCode errorCode, String context) {
           super(errorCode, context);
       }
   }
   ```

2. **智能错误码生成**：
   ```
   提示词：@codebase 基于现有错误码枚举，为新模块生成标准错误码定义
   要求遵循：
   - 现有的错误码格式规范
   - 错误码分类和编号策略  
   - 错误消息模板格式
   - 国际化支持方式
   ```

## 二、智能异常处理实现

### 【项目适配】Controller层智能异常处理
1. **基于Cursor的全局异常处理分析**：
   ```java
   // 第一步：分析现有全局异常处理器
   // 提示词：@codebase 分析@RestControllerAdvice类，总结异常处理模式和响应格式
   
   // 第二步：按照项目现有模式实现
   @RestControllerAdvice
   @Slf4j
   public class GlobalExceptionHandler {
       
       // 基于项目现有的响应类型进行处理
       @ExceptionHandler(ProjectBizException.class)
       public ResponseEntity<ProjectResult> handleBizException(ProjectBizException e) {
           // 使用项目现有的Result构建方式
           ProjectResult result = ProjectResult.error(e.getErrorCode(), e.getMessage());
           return ResponseEntity.ok(result); // 或根据项目模式返回特定HTTP状态码
       }
       
       // 根据项目现有异常类型添加相应处理器
       @ExceptionHandler(MethodArgumentNotValidException.class)
       public ResponseEntity<ProjectResult> handleValidationException(MethodArgumentNotValidException e) {
           // 按项目现有的参数校验异常处理模式
           String message = e.getBindingResult().getFieldErrors().stream()
                   .map(FieldError::getDefaultMessage)
                   .collect(Collectors.joining(", "));
           return ResponseEntity.badRequest().body(ProjectResult.error("20001", message));
       }
   }
   ```

2. **智能异常处理器生成**：
   ```
   提示词：@codebase 基于现有GlobalExceptionHandler，为新的异常类型生成标准处理器
   分析维度：
   - 异常类型与HTTP状态码映射规律
   - 错误响应的统一格式
   - 日志记录的规范模式
   - TraceId等追踪信息的添加方式
   ```

### 【项目适配】Service层智能异常处理
1. **基于现有模式的Service异常处理**：
   ```java
   // 第一步：分析现有Service层异常处理模式
   // 提示词：@codebase 分析Service实现类的异常处理方式，总结异常转换模式
   
   @Service
   @RequiredArgsConstructor
   @Slf4j
   public class OrderServiceImpl implements OrderService {
       
       private final OrderRepository orderRepository;
       
       @Override
       @Transactional(rollbackFor = Exception.class)
       public OrderResult createOrder(CreateOrderRequest request) {
           try {
               // 业务逻辑实现
               Order order = orderRepository.save(newOrder);
               
               // 按项目现有模式返回结果
               return OrderResult.success(order);
               
           } catch (DataAccessException e) {
               // 根据项目现有的异常转换模式
               log.error("创建订单时数据库操作失败，请求：{}", request, e);
               throw new ProjectBizException(ProjectErrorCode.DATABASE_ERROR, e.getMessage());
               
           } catch (BusinessValidationException e) {
               // 业务校验异常的处理
               log.warn("订单创建业务校验失败：{}", e.getMessage());
               throw new ProjectBizException(ProjectErrorCode.BUSINESS_VALIDATION_FAILED, e.getMessage());
           }
       }
   }
   ```

2. **智能异常转换策略分析**：
   ```
   提示词：@codebase 分析Service层异常转换策略，生成标准异常处理模板
   检查内容：
   - 第三方异常转换为项目异常的模式
   - 异常日志记录的级别和内容规范
   - 事务异常处理的标准做法
   - 异常链保留和错误上下文传递
   ```

## 三、智能日志处理规范

### 【项目适配】日志配置智能分析
1. **基于Cursor的日志框架分析**：
   ```
   提示词：@codebase 分析logback-spring.xml和application.yml中的日志配置，总结日志规范
   分析内容：
   - 日志框架组合（SLF4J + Logback/Log4j2）
   - 日志级别配置策略
   - 日志文件分割和保留策略
   - 异步日志配置模式
   - MDC上下文信息配置
   ```

2. **智能日志内容规范**：
   ```java
   // 基于项目现有的日志记录模式
   @Service
   @Slf4j
   public class UserServiceImpl implements UserService {
       
       @Override
       public UserInfo getUserInfo(Long userId) {
           // 入参日志：根据项目现有模式记录
           log.info("获取用户信息，用户ID：{}", userId);
           
           try {
               UserInfo userInfo = userRepository.findById(userId);
               
               // 成功日志：根据项目敏感信息处理规范
               log.info("用户信息获取成功，用户ID：{}，用户名：{}", 
                       userId, userInfo.getMaskedUsername());
               
               return userInfo;
               
           } catch (Exception e) {
               // 异常日志：包含TraceId等追踪信息
               log.error("获取用户信息失败，用户ID：{}，错误：{}", userId, e.getMessage(), e);
               throw new ProjectBizException(ProjectErrorCode.USER_NOT_FOUND, userId.toString());
           }
       }
   }
   ```

3. **智能敏感信息处理**：
   ```
   提示词：@codebase 分析现有代码中的敏感信息处理方式，生成脱敏处理规范
   检查内容：
   - 敏感字段的@JsonIgnore使用
   - toString方法的敏感信息排除
   - 日志中敏感信息的脱敏处理
   - 审计日志的记录规范
   ```

## 四、智能参数校验规范

### 【项目适配】参数校验策略分析
1. **基于Cursor的校验注解分析**：
   ```
   提示词：@codebase 分析所有Request/DTO类的校验注解使用，总结参数校验规范
   分析内容：
   - JSR303注解的使用模式和自定义校验注解
   - 校验分组的使用情况
   - 校验失败消息的国际化支持
   - 业务校验与格式校验的分离方式
   ```

2. **智能校验规则生成**：
   ```java
   // 基于项目现有的校验模式
   public class CreateOrderRequest {
       
       @NotNull(message = "用户ID不能为空")
       @Positive(message = "用户ID必须为正数")
       private Long userId;
       
       @NotEmpty(message = "商品列表不能为空")
       @Valid
       private List<@Valid OrderItemRequest> items;
       
       // 根据项目现有的自定义校验注解
       @ProjectValidEnum(enumClass = OrderTypeEnum.class, message = "订单类型不正确")
       private String orderType;
       
       // 敏感信息保护
       @JsonIgnore
       private String internalToken;
   }
   ```

3. **智能校验异常处理**：
   ```
   提示词：@codebase 分析参数校验异常的处理方式，生成标准校验失败响应
   要求包含：
   - 校验失败消息的格式化方式
   - 多个校验错误的聚合处理
   - 校验异常与业务异常的区分
   - 校验失败的HTTP状态码策略
   ```

## 五、智能响应格式规范

### 【项目适配】响应包装类分析
1. **基于Cursor的响应格式分析**：
   ```
   提示词：@codebase 分析所有Controller返回值类型，确定统一响应格式
   分析内容：
   - Result/ApiResponse等响应包装类的结构
   - 成功和失败响应的格式差异
   - 分页响应的特殊处理
   - TraceId等追踪信息的添加方式
   ```

2. **智能响应构建**：
   ```java
   // 基于项目现有的Result类结构
   @RestController
   @RequestMapping("/api/orders")
   @RequiredArgsConstructor
   public class OrderController {
       
       private final OrderService orderService;
       
       @PostMapping("/create")
       public ProjectResult<OrderResponse> createOrder(@Valid @RequestBody CreateOrderRequest request) {
           try {
               OrderInfo orderInfo = orderService.createOrder(request);
               OrderResponse response = convertToResponse(orderInfo);
               
               // 使用项目现有的成功响应构建方式
               return ProjectResult.success(response);
               
           } catch (ProjectBizException e) {
               // 异常已在GlobalExceptionHandler中统一处理
               throw e;
           }
       }
   }
   ```

## 六、Cursor智能辅助异常处理开发

### 【推荐】基于@codebase的智能代码生成
1. **完整异常处理体系生成**：
   ```
   提示词模板：
   @codebase 基于现有异常处理模式，为 [新业务模块] 生成完整的异常处理代码，包括：
   1. 自定义异常类定义
   2. 错误码枚举扩展
   3. GlobalExceptionHandler更新
   4. Service层异常处理模板
   
   要求遵循项目现有的：
   - 异常类继承结构
   - 错误码格式规范
   - 日志记录模式
   - 响应格式标准
   ```

2. **异常处理规范检查**：
   ```
   提示词模板：
   @codebase 检查这段代码的异常处理是否符合项目规范：
   1. 异常类型是否正确
   2. 错误码使用是否规范
   3. 日志记录是否完整
   4. 异常转换是否合理
   
   [粘贴需要检查的代码]
   ```

### 【推荐】基于@codebase的问题诊断
1. **异常处理问题分析**：
   ```
   提示词模板：
   @codebase 分析这个异常处理问题，基于项目现有实现提供解决方案：
   [粘贴异常日志和相关代码]
   
   请检查：
   1. 异常处理链是否完整
   2. 错误码和消息是否正确
   3. 日志记录是否规范
   4. HTTP状态码映射是否合理
   ```

2. **日志质量优化建议**：
   ```
   提示词模板：
   @codebase 分析这段代码的日志记录，对比项目最佳实践：
   [粘贴代码片段]
   
   分析维度：
   1. 日志级别选择
   2. 敏感信息处理
   3. 异常堆栈记录
   4. 追踪信息完整性
   ```

## 七、常见问题与解决方案

### 【FAQ】基于Cursor的问题解决
1. **异常处理不规范诊断**：
   ```
   提示词模板：
   @codebase 识别项目中异常处理不规范的代码，生成修改建议：
   包括：
   1. 异常吞并或简单printStackTrace
   2. 异常类型使用不当
   3. 错误码缺失或不规范
   4. 日志记录不完整
   ```

2. **性能问题排查**：
   ```
   提示词模板：
   @codebase 分析异常处理相关的性能问题：
   [描述性能问题]
   
   检查：
   1. 异常创建频率
   2. 日志记录性能
   3. 异常堆栈获取开销
   4. 异步日志配置优化
   ```

---

## 八、智能化规范集成

### 【重要】与其他规范的智能协同
1. **HTTP API集成**：
   ```
   提示词：@codebase 基于 [java-http-api.mdc](mdc:.cursor/rules/java-http-api.mdc) 规范，确保异常处理与HTTP接口响应格式的一致性
   ```

2. **RPC服务集成**：
   ```
   提示词：@codebase 基于 [java-rpc-service.mdc](mdc:.cursor/rules/java-rpc-service.mdc) 规范，优化RPC服务中的异常处理和错误码传递
   ```

3. **数据持久化集成**：
   ```
   提示词：@codebase 基于 [java-data-persistence.mdc](mdc:.cursor/rules/java-data-persistence.mdc) 规范，确保数据库操作异常的正确处理和转换
   ```

### 【核心价值】智能化带来的效果
- **🎯 精准适配**：AI理解项目异常处理模式，生成完全符合项目风格的代码
- **⚡ 效率提升**：从手工分析到AI智能生成，异常处理开发效率提升10倍
- **🛡️ 质量保证**：AI检查确保异常处理的规范性和一致性
- **📚 知识传承**：项目经验通过AI规范化传递给团队成员
- **🔍 问题发现**：智能识别异常处理中的潜在问题和安全风险 