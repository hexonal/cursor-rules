---
description: 
globs: 
alwaysApply: true
---
# Java项目代码开发与质量规范

本规范旨在统一Java项目的代码编写风格、质量标准、测试要求和提交过程，以确保代码的健壮性、可读性和可维护性。

## 一、代码编写规范

### 【强制】方法设计原则
1. 原子性原则：
   - 一个方法只做一件事情
   - 方法的功能必须具有原子性，不可再分
   - 避免在一个方法中混合多个业务逻辑
   - 修改操作必须保证事务的原子性
   - **【DDD增强】对于领域实体（Domain Entity），其方法应封装该实体自身的业务行为和状态变更逻辑，体现充血模型的特点。避免将属于实体的行为泄露到Service层。**

2. 可读性原则：
   - 方法名必须清晰表达其功能
   - 参数命名必须见名知意
   - 复杂逻辑必须添加注释说明
   - 避免使用魔法数字，应该使用常量定义

3. 分层原则：
   ```java
   @Service
   @RequiredArgsConstructor  // 使用构造器注入
   public class XxxBizServiceImpl implements XxxBizService {
       // 注入依赖
       private final XxxRpcProxyService xxxRpcProxyService;

       @Override
       public void doSomething(XxxReq req) {
           // 1. 参数校验
           validateParams(req);

           // 2. 业务处理
           xxxRpcProxyService.doSomething(req);

           // 3. 结果处理（如果需要）
           handleResult();
       }
   }
   ```

### 【强制】业务代码规范
1. 服务实现类：
   - 必须使用 @Service 注解
   - 必须使用 @RequiredArgsConstructor 进行依赖注入
   - 必须实现对应的接口
   - 类名必须以 ServiceImpl 或 BizServiceImpl 结尾
   - **【DDD增强】应用服务 (`ApplicationService`, 通常对应这里的 `XxxServiceImpl` 或 `XxxBizServiceImpl`) 主要负责编排领域对象（Entities, Value Objects, Domain Services）完成业务用例，处理事务、安全、通知等横切关注点，不应包含核心领域逻辑。核心领域逻辑应封装在领域实体和领域服务中。**

2. 方法实现：
   - 必须添加 @Override 注解
   - 必须进行参数校验
   - 必须处理异常情况
   - 必须记录关键日志

3. 事务处理：
   ```java
   @Transactional(rollbackFor = Exception.class)
   public void updateData(XxxReq req) {
       // 1. 数据校验
       validateData(req);

       // 2. 更新操作
       doUpdate(req);

       // 3. 结果处理
       handleResult();
   }
   ```

4. 手动事务处理规范：
   在需要更细粒度控制或特定场景下，可以考虑手动管理事务。但优先推荐使用Spring的编程式事务管理（如`TransactionTemplate`）。若直接使用JDBC进行手动事务管理，必须遵循以下规范：

   a. **适用场景**：
      - 事务边界无法简单通过 `@Transactional` 定义在方法级别时。
      - 需要在一个业务方法内执行多个独立的、需要精细控制的事务单元。
      - 与某些不支持Spring声明式事务的特定组件交互，且该组件自身提供事务API时。

   b. **【强制】获取与释放资源**：
      - 数据库连接必须通过依赖注入的 `DataSource` 的 `getConnection()` 方法获取。
      - 必须在 `finally` 块中确保 `Connection`、`Statement`、`ResultSet` 等资源被正确关闭，即使发生异常。顺序为：先 `ResultSet`，再 `Statement`，最后 `Connection`。
      - 强烈推荐使用 `try-with-resources` 语句（Java 7+）自动管理资源，以简化代码并减少遗漏关闭的风险。
        ```java
        // 推荐使用 try-with-resources
        try (Connection conn = dataSource.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(SQL_XXX)) {
            // ... 设置参数并执行
        } catch (SQLException e) {
            // ... 处理异常
        }
        ```

   c. **【强制】事务边界显式控制**：
      - 在开启事务前，必须调用 `connection.setAutoCommit(false);`。
      - 业务逻辑成功完成后，必须调用 `connection.commit();` 提交事务。
      - 当发生 `SQLException` 或业务逻辑判断需要回滚时，必须在 `catch` 块或相应逻辑中调用 `connection.rollback();`。
      - 示例结构：
        ```java
        Connection conn = null;
        try {
            conn = dataSource.getConnection();
            conn.setAutoCommit(false); // 开始事务

            // ... 执行数据库操作1
            // ... 执行数据库操作2

            conn.commit(); // 提交事务
        } catch (SQLException e) {
            if (conn != null) {
                try {
                    conn.rollback(); // 回滚事务
                } catch (SQLException ex) {
                    // 记录回滚失败的日志，参考 @java-error-handling-and-operations.mdc 日志规范
                    log.error("Transaction rollback failed", ex);
                }
            }
            // 将SQLException转换为com.hexonal.ht.common.exception.BizException，参考 @java-error-handling-and-operations.mdc
            // BizErrorCode.DATABASE_OPERATION_FAILED 为示例错误码，请替换为实际定义的错误码
            throw new com.hexonal.ht.common.exception.BizException(com.hexonal.ht.common.exception.BizErrorCode.DATABASE_OPERATION_FAILED, "Database operation failed: " + e.getMessage(), e);
        } finally {
            if (conn != null) {
                try {
                    conn.setAutoCommit(true); // 恢复自动提交（可选，取决于连接池配置和后续使用）
                    conn.close(); // 关闭连接（归还到连接池）
                } catch (SQLException e) {
                    log.error("Failed to close connection", e);
                }
            }
        }
        ```

   d. **【强制】异常处理与日志**：
      - 所有 `SQLException` 都必须被捕获。
      - 捕获异常后，如果事务需要回滚，则执行回滚操作。
      - 必须记录详细的错误日志，包含错误信息、堆栈、可能的业务上下文，遵循 `@java-error-handling-and-operations.mdc` 的日志规范。
      - 最终应将底层的 `SQLException` (以及其他受检查异常或特定的运行时异常) 包装成或转换为 `com.hexonal.ht.common.exception.BizException` (携带合适的 `BizErrorCode`) 向上抛出，遵循 `@java-error-handling-and-operations.mdc` 的异常处理规范。对于无法通过 `BizErrorCode` 归类的、非预期的运行时故障，可按该规范使用 `SystemException`。

   e. **【推荐】Spring编程式事务**：
      - **优先推荐**：即使需要手动控制事务的执行点，也应优先考虑使用Spring提供的 `TransactionTemplate`。它简化了手动事务管理的复杂性，减少了样板代码，并能更好地集成Spring的事务同步和资源管理机制。
      - `TransactionTemplate` 示例:
        ```java
        // import com.hexonal.ht.common.exception.BizException;
        // import com.hexonal.ht.common.exception.BizErrorCode; // 假设BizErrorCode已定义
        @Autowired
        private TransactionTemplate transactionTemplate;
        // 可以注入其他需要在此事务中操作的Service或DAO组件，例如:
        // @Autowired 
        // private YourCustomService yourCustomService;
        // @Autowired 
        // private YourCustomDao yourCustomDao;

        public void doSomethingInTransaction() {
            transactionTemplate.execute(status -> {
                try {
                    // 执行数据库操作1 (例如通过注入的Service/DAO):
                    // yourCustomService.doWork1();
                    // yourCustomDao.updateData1();
                    // System.out.println("执行数据库操作1");

                    // 执行数据库操作2 (例如通过注入的Service/DAO):
                    // yourCustomService.doWork2();
                    // yourCustomDao.updateData2();
                    // System.out.println("执行数据库操作2");

                    // 如果没有异常，事务会自动提交
                    return null; // 或返回一个结果，如果方法签名是 TransactionCallback<T>
                } catch (DataAccessException e) { // Spring的通用数据访问异常
                    status.setRollbackOnly(); // 标记事务为仅回滚
                    log.error("Transaction failed due to DataAccessException, rolling back.", e);
                    // 将DataAccessException转换为com.hexonal.ht.common.exception.BizException
                    // BizErrorCode.TRANSACTION_FAILED_DATA_ACCESS 为示例错误码
                    throw new com.hexonal.ht.common.exception.BizException(com.hexonal.ht.common.exception.BizErrorCode.TRANSACTION_FAILED_DATA_ACCESS, "Operation failed within transaction due to DataAccessException", e);
                } catch (Exception e) { // 可根据需要捕获更具体的业务异常或检查型异常
                    status.setRollbackOnly();
                    log.error("Transaction failed due to an unexpected exception, rolling back.", e);
                    // 转换为com.hexonal.ht.common.exception.BizException
                    // BizErrorCode.TRANSACTION_FAILED_UNEXPECTED 为示例错误码
                    throw new com.hexonal.ht.common.exception.BizException(com.hexonal.ht.common.exception.BizErrorCode.TRANSACTION_FAILED_UNEXPECTED, "Operation failed unexpectedly within transaction", e);
                }
            });
        }
        ```
      - 如果需要更底层的控制，可以直接注入 `PlatformTransactionManager` (例如 `DataSourceTransactionManager`)，并使用 `TransactionDefinition` 和 `TransactionStatus` 手动开启、提交、回滚事务。这种方式比直接操作JDBC Connection更安全，但比 `TransactionTemplate` 复杂。

   f. **【警告】避免滥用手动事务**：
      - 仅在Spring声明式事务 (`@Transactional`) 确实无法满足需求，且细粒度控制确实必要时才考虑手动事务。
      - 手动事务代码更容易出错（如忘记释放资源、错误处理不当），增加了代码复杂度和维护成本。

   g. **【注意】事务隔离级别与传播行为**：
      - 直接使用JDBC Connection时，可以通过 `connection.setTransactionIsolation(int level)` 设置隔离级别。但需谨慎，不当的隔离级别可能导致数据一致性问题或性能下降。
      - 如果使用Spring编程式事务（`TransactionTemplate`或`PlatformTransactionManager`），可以通过`TransactionDefinition`设置隔离级别和传播行为，其行为与声明式事务类似。

### 【强制】命名规范
1. 类命名：
   - 领域模型类：
     - **【DDD增强】领域实体 (Entity, 具有唯一标识，封装核心业务逻辑和状态)：`Xxx` 或 `XxxEntity` (例如 `Order`, `UserEntity`)。实体类应包含其自身的业务方法，体现充血特性。**
     - **【DDD增强】值对象 (Value Object, 无唯一标识，描述性属性集合)：`XxxValue` 或直接使用描述性名称 (例如 `AddressValue`, `Money`)。**
     - **【DDD增强】领域服务 (Domain Service, 当某些领域逻辑不适合放在任何一个实体或值对象中时使用)：`XxxDomainService` (例如 `OrderPricingDomainService`)。**
     - **【DDD增强】应用服务 (Application Service, 协调领域层对象完成用例，处理事务、权限等)：`XxxAppService` 或保持现有的 `XxxService` / `XxxBizService` （其实现类为 `XxxAppServiceImpl` / `XxxServiceImpl` / `XxxBizServiceImpl`）。**
     - **【DDD增强】工厂 (Factory, 负责复杂对象的创建)：`XxxFactory` (例如 `OrderFactory`)。**
     - **【DDD增强】仓库 (Repository, 负责领域对象的持久化和读取，提供集合一样的接口操作领域对象)：`XxxRepository` (例如 `OrderRepository`)。其实现类通常位于DAO层或一个独立的持久化层。**
   - 数据持久化对象 (DO, Data Object, 与数据库表结构一一对应，用于ORM)：`XxxDO`。**注意：在DDD中，DO主要用于数据持久化，领域实体 (`XxxEntity`) 承载业务逻辑。Repository负责Entity与DO之间的转换。**
   - 数据传输对象 (DTO, Data Transfer Object, 用于应用层与外部（如表示层、RPC调用方）之间的数据传输)：`XxxDTO`。
   - 数据传输rpc传入入参对象: `XxxRpcReq` (可视为一种特定用途的DTO)
   - 数据传输rpc传入出参对象：`XxxRpcResp` (可视为一种特定用途的DTO)
   - 实体类中的get/set方法使用lombok来完成 (适用于DO和DTO，领域实体的方法应具有业务含义，不仅仅是getter/setter)
   - 请求对象：`XxxReq` (通常用于Controller层，可视为一种特定用途的DTO)
   - 响应对象：`XxxResp` (通常用于Controller层，可视为一种特定用途的DTO)
   - dao实体类: `XxxDO`
   - dao关联的myabtis-plus接口: `XxxMapper extends BaseMapper<XxxDO>`
   - dao服务接口：`XxxDAO extends IService<XxxDO>`
   - dao服务实现：`XxxDAOImpl extends ServiceImpl<XxxMapper, XxxDO> implements XxxDAO`
     - **【DDD增强】或者，Repository接口 `XxxRepository`，其实现 `XxxRepositoryImpl` 内部可以依赖 `XxxDAO` 或 `XxxMapper` 来完成数据持久化。**
   - biz服务接口：`XxxService` (或 `XxxAppService`)
   - biz服务实现：`XxxServiceImpl` (或 `XxxAppServiceImpl`)
   - 控制器：`XxxController`
   - 工具类：`XxxUtils`
   - 操作redis相关的类: `hexonalJedis`
   - 操作分页相关的类: `PageUtils`
   - rpc的接口命名: `XxxRpcService`
   - rpc的接口实现命名: `XxxRpcServiceImpl`
   - rpc调用方接口命名: `XxxRpcProxyService`
   - rpc调用接口实现命名: `XxxRpcProxyServiceImpl`
   - rpc实现统一需要继承: `extends BaseRpcService`
   - 实体类需要实现: `implements Serializable` (DO和DTO通常需要序列化，领域实体按需)
2. 方法命名：
   - **【DDD增强】领域实体的方法命名应直接体现业务动作，例如 `order.cancel()`，`product.applyDiscount(discountRate)`。**
   - 获取单个对象：`getXxx` (用于应用服务或仓库) 或 `findXxx` (常用于仓库)
   - 获取多个对象：`listXxx` (用于应用服务或仓库) 或 `findAllXxx` (常用于仓库)
   - 统计数量：`countXxx`
   - 新增：`createXxx` (用于应用服务) 或 `saveXxx` / `addXxx` (常用于仓库)
   - 修改：`updateXxx` (用于应用服务) 或 `saveXxx` (常用于仓库，表示保存状态变更)
   - 删除：`deleteXxx` (用于应用服务或仓库)
   - 分页: `pageXXX`
3. 变量命名：
   - 常量：全大写下划线分隔
   - 变量：驼峰命名
4. 项目代码创建规范,需要根据模块定义: (此条目更偏向项目结构，但为保持完整性暂时保留)
   - xxx-api模块: 提供rpc相关接口
   - xxx-api-impl模块: 实现接口相关实现
   - xxx-biz模块: 业务实现层
   - xxx-common模块: 通用能力
   - xxx-dao模块: 提供数据库交互的原子化能力
   - xxx-integration模块: 提供调用外部调用的能力,如http或者rpc等
   - xxx-web模块： 提供对外暴露的http接口

### 【强制】注释规范
1. 类注释：
   ```java
   /**
    * 类的功能描述
    *
    * @author 作者
    * @date 创建时间 yyyy-MM-dd
    * @version 版本号
    */
   ```
2. 方法注释：
   ```java
   /**
    * 方法的功能描述
    *
    * @param 参数名 参数说明
    * @return 返回值说明
    * @throws 异常类型 异常说明
    * @version 版本号
    * @author 作者
    * @date 创建时间 yyyy-MM-dd
    */
   ```
3. 字段注释：
   ```java
   /** 
    * 字段说明
    * @mock 模拟数据（如果需要）
    */
   private String field;
   ```
4. 常量注释：
   ```java
   /**
    * 常量说明
    * 例如：订单状态 - 已支付
    */
   public static final int ORDER_STATUS_PAID = 1;
   ```

### 【强制】代码格式
1. 缩进：4个空格
2. 行宽：最大120字符
3. 花括号：
   - 左花括号不换行
   - 右花括号独占一行
4. 空行：
   - 方法间空一行
   - 逻辑块间空一行
5. 导包：
   - 按类型分组
   - 组间空一行
   - 禁止使用*导入
6. 禁止使用行尾注释

### 【强制】编码实践
1. 异常处理：
   - 应用中所有通过 `throw` 语句显式抛出或转换的异常，应统一使用 `com.hexonal.ht.common.exception.BizException`（参考 `com.hexonal.ht.common.exception.BizException.java` 文件）。
   - `BizException` 通过其错误码（如 `com.hexonal.ht.common.exception.BizErrorCode`）区分不同类型的错误（业务错误、服务错误、可预期的系统操作错误）。对于极其罕见的、无法通过 `BizErrorCode` 归类的运行时故障，可使用 `SystemException` (参考 `@java-error-handling-and-operations.mdc` 中的异常分类)。
   - 必须记录详细日志，遵循 `@java-error-handling-and-operations.mdc` 的日志规范。
   - 必须进行统一异常处理（如通过 `@RestControllerAdvice`），遵循 `@java-error-handling-and-operations.mdc` 的异常响应处理规范。
2. 日志打印：(部分内容与 hexonal-error-handling.mdc 重叠，后续统一处理)
   - 必须使用Log4j2
   - 必须使用占位符
   - 必须进行日志级别判断
   - 必须包含追踪ID
3. 工具类：
   - 必须私有构造函数
   - 必须使用静态方法
   - 必须编写单元测试
4. 配置加载： (部分内容与 hexonal-error-handling.mdc 重叠，后续统一处理)
   - 必须使用Apollo配置中心
   - 必须使用@ConfigurationProperties
   - 必须进行配置验证

### 【强制】依赖注入规范
1. 构造器注入：
   - 优先使用构造器注入
   - 使用 @RequiredArgsConstructor 注解
   - final 修饰依赖字段

2. 字段注入：
   - 禁止使用 @Autowired 注解注入字段
   - 禁止使用 @Resource 注解注入字段

3. 方法注入：
   - 只在特殊场景下使用
   - 必须说明使用原因

### 【强制】代码修改范围限制
1. 方法修改原则：
   - 只能修改目标方法的内部实现
   - 禁止修改方法的签名（参数列表和返回类型）
   - 禁止修改方法的访问修饰符
   - 禁止删除或修改现有的注解
   - 禁止使用魔法值

2. 关联代码限制：
   - 禁止修改非关联代码
   - 禁止修改被未提到的代码

3. 依赖管理：
   - 禁止修改现有的依赖注入
   - 如需添加新的依赖，必须遵循构造器注入规范
   - 禁止修改其他类的依赖关系

4. 事务边界：
   - 禁止改变现有的事务边界
   - 禁止修改事务传播行为
   - 如需调整事务配置，必须单独评估影响

5. 异常处理： (此部分与 hexonal-error-handling.mdc 高度相关，后续统一)
   - 禁止删除现有的异常处理逻辑
   - 禁止修改异常抛出链
   - 可以增加新的异常处理，但不能影响现有流程

6. 日志记录： (此部分与 hexonal-error-handling.mdc 高度相关，后续统一)
   - 禁止删除现有的关键日志
   - 禁止修改日志级别
   - 可以增加新的日志记录点

7. 代码提交：
   - 每次修改必须限定在单一职责范围内
   - 提交信息必须清晰说明修改范围
   - 必须通过代码审查确认修改范围合规

### 遵守 SOLID 原则，确保 Spring Boot 应用程序设计的高内聚性和低耦合性。

## 二、代码质量与测试规范

### 【强制】代码质量规范
1. 性能要求：
   - 避免在循环中进行数据库操作
   - 避免在循环中进行远程调用
   - 批量操作必须控制数量
   - 必要时使用缓存优化
   - 代码需要考虑性能问题，避免代码产生一些阻塞性的问题
   - **【DDD增强】在充血模型中，领域实体的方法可能会触发关联对象的加载（懒加载或即时加载）。需要关注N+1查询问题，通过Repository层进行优化，或在领域服务中进行批量操作的协调。**

2. 代码组织：
   - 相关的字段放在一起
   - 相关的方法放在一起
   - 公共方法放在前面
   - 私有方法放在后面
   - 增加适当的换行,避免代码都堆这一坨,导致review过乱
   - **【DDD增强】领域模型内部：实体类应将与其状态紧密相关的行为组织在一起。聚合根（Aggregate Root）应负责其边界内所有对象的一致性。**

3. 可维护性要求：
   - 代码必须符合阿里巴巴Java开发手册规范
   - 必须编写单元测试
   - 必须处理所有异常情况
   - 必须添加必要的注释

### 【强制】单元测试规范
1. 测试用例编写：
   ```java
   @SpringBootTest
   public class XxxServiceTest {
       @Autowired
       private XxxService xxxService;

       @Test
       public void testXxx() {
           // 1. 准备测试数据
           XxxReq req = new XxxReq();
           req.setField("value");

           // 2. 执行测试
           XxxResp resp = xxxService.doSomething(req);

           // 3. 验证结果
           assertNotNull(resp);
           assertEquals("expected", resp.getField());
       }
   }
   ```

2. 测试覆盖要求：
   - 核心业务代码测试覆盖率不低于80%
   - 必须覆盖所有异常分支
   - 必须覆盖所有边界条件

### 【强制】测试规范
1. 单元测试
   - 测试类命名：XxxTest
   - 测试方法命名：test_方法名_场景
   - 必须包含断言
   - 必须考虑边界条件
2. 测试覆盖率
   - 分支覆盖率：>80%
   - 行覆盖率：>80%
   - 方法覆盖率：>90%
   - 类覆盖率：>90%

## 三、代码提交规范

### 【强制】提交信息格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

1. type类型：
   - feat：新功能
   - fix：修复bug
   - docs：文档更新
   - style：代码格式调整
   - refactor：重构代码
   - test：测试用例
   - chore：其他修改
2. scope范围：
   - 影响的功能模块
   - 可选，放在括号中
3. subject主题：
   - 简短描述本次提交
   - 不超过50个字符
   - 使用现在时态
4. body正文：
   - 详细描述改动原因
   - 可以分多行
   - 可选
5. footer脚注：
   - 关闭Issue编号
   - Breaking Changes
   - 可选

### 【强制】提交原则
1. 单一职责：
   - 每次提交只做一件事
   - 相关的改动放在一起
   - 不相关的改动分开提交
2. 提交频率：
   - 小步提交
   - 保持提交粒度合适
   - 避免积压大量改动
3. 提交时机：
   - 功能开发完成
   - 修复bug完成
   - 重构完成
   - 测试用例完成

### 【强制】代码审查
1. 审查要求：
   - 所有代码必须经过审查
   - 至少一个审查人通过
   - 解决所有审查意见
2. 审查内容：
   - 代码规范
   - 业务逻辑
   - 性能问题
   - 安全问题
3. 审查流程：
   - 提交合并请求
   - 指定审查人
   - 修改并更新
   - 审查人确认

## 四、代码修改边界与稳定性规范

本章节旨在定义代码修改的基本原则和边界，以保障系统的稳定性和可维护性，减少因修改引入的潜在风险。

### 【核心原则】最小化影响与职责单一
1.  **职责边界清晰**：
    *   每个模块、服务或组件都应有明确定义的职责。
    *   代码修改应严格限制在当前模块或组件的职责边界内，避免随意修改或依赖其他不相关模块的内部实现。
    *   修改前需充分理解模块的既定职责和与其他模块的协定。

2.  **影响范围评估**：
    *   任何修改前，必须评估其潜在影响范围，包括对上游调用者、下游依赖方以及系统整体性能和稳定性的影响。
    *   对于影响较大的修改，需要制定详细的方案、回滚计划，并进行充分的沟通。

### 【强制】接口与契约稳定性
1.  **对外接口（HTTP API / RPC API）**：
    *   **优先扩展**：对于已发布的接口，当需要增加功能或改变行为时，应优先考虑新增接口或在现有接口上新增方法（如果协议支持且不破坏兼容性），而非直接修改原有接口签名或核心行为。
    *   **废弃策略**：旧接口或方法在有替代方案后，应标记为 `@Deprecated`，提供明确的迁移指南和废弃时间表，并通知所有已知调用方。
    *   **兼容性**：任何对接口的修改（如参数增减、类型变更、返回值结构调整、核心业务逻辑变更）都必须经过严格的兼容性评估。不兼容的修改需要上升版本号（参考 `@java-project-architecture-and-structure.mdc` 中的版本管理规范），并与所有依赖方协调升级。
    *   接口行为的修改（即使签名不变）也需谨慎，确保符合接口文档和调用方预期。

2.  **内部公共方法/类库**：
    *   作为内部共享的工具类、基础服务或公共组件，其公共方法和类定义也应保持高度稳定性。
    *   修改这些公共部分前，必须评估对项目内所有使用方的影响。
    *   修改原则同对外接口，优先保证向后兼容。

### 【推荐】通过配置与扩展点适应变化
1.  **配置驱动**：对于易变的业务规则、阈值、开关等，应优先通过外部配置文件（如 `.properties`, `.yml`）或配置中心进行管理，避免硬编码在代码中。
2.  **扩展点设计**：在核心流程中，对可能发生变化或需要定制化的部分，可以预留清晰的扩展点（如策略模式、模板方法、事件监听、插件机制），使得新功能的增加或行为的调整可以通过实现扩展接口而非修改核心代码来完成。

### 【强制】公共组件与基础框架的修改
1.  **严格控制**：对公司级共享的基础组件、框架（如 `yp-commons` 等）的修改，必须遵循更严格的审批流程和代码审查标准。
2.  **充分测试与通知**：修改后必须进行全面的回归测试和兼容性测试，确保不会对现有业务产生负面影响。发布新版本后，需及时通知所有依赖的项目团队。

### 【强制】测试覆盖与验证
1.  **伴随测试**：任何代码修改（无论是bug修复还是功能新增）都必须伴随相应的单元测试、集成测试（如果适用）。
2.  **测试边界**：测试用例需要覆盖修改点及其直接影响的逻辑边界。对于有潜在广泛影响的修改，需要考虑更全面的端到端测试或场景测试。
3.  **回归测试**：确保修改没有破坏已有的功能。

### 【强制】遵循版本控制与分支策略
1.  **分支操作**：所有代码修改必须在独立的特性分支或修复分支上进行，严禁直接向主干分支（如 `master` 或 `main`）推送未经评审和测试的代码。
2.  **合并流程**：分支合并回主干前，必须通过代码审查 (Code Review) 和所有自动化测试。
3.  **提交信息**：遵循项目既定的提交信息规范（参考本文档"代码提交规范"部分）。

### 【强制】文档同步
1.  **及时更新**：代码修改后，如果涉及到架构设计、接口定义、重要业务逻辑、配置项等，相关的设计文档、API文档（如Swagger）、README、注释等必须同步更新。
2.  **变更记录**：对于重要的接口或功能变更，建议在文档中保留清晰的变更历史记录。
3.  **【DDD增强】架构图与模型图**：在技术方案文档中，推荐使用 Mermaid 语法绘制领域模型图（如聚合、实体、值对象关系图）、限界上下文映射图等，以清晰表达DDD设计。

---

## 五、AI辅助编码与规范融合实践

### 5.1 激活AI高级能力辅助编码与合规
- **代码库模式检索与应用 (如引导AI调用 `codebase_search`, `grep_search`)**: 当需要实现特定功能或模式，但不确定如何在当前项目中最佳实践时，可引导AI利用代码搜索能力，在项目中查找符合 `@java-code-development-and-quality.mdc` 规范的现有实现作为参考。例如，查找特定异常处理、日志格式、事务管理或设计模式的合规应用实例。
- **复杂编码任务的结构化拆解 (如引导AI调用 `mcp_sequential-thinking_sequentialthinking`)**: 对于复杂的函数实现、模块重构或算法设计，可以引导AI运用结构化思考能力，将任务分解为更小、更易管理步骤。确保每一步的设计和实现都考虑到本规范的各项要求（如方法原子性、参数校验、异常处理、日志记录等），从而系统性地构建出高质量且合规的代码。
- **库使用与最佳实践探索 (如引导AI调用 `mcp_context7_resolve-library-id`, `mcp_context7_get-library_docs`)**: 在引入新库或使用现有库的复杂功能时，可引导AI调用文档获取能力，深入理解库的API、最佳实践和潜在陷阱。这有助于编写出更健壮、高效且符合预期的代码，避免不当使用导致的质量问题。

### 5.2 AI作为编码规范的实时顾问
- **即时规范查询与解读**：在编码过程中，遇到对本规范 (`@java-code-development-and-quality.mdc`) 具体条款（如命名约定、方法设计原则、异常处理方式、注释标准等）的疑问时，可以直接向AI提问。例如："请解释一下本规范中关于Service层方法原子性的要求"，或"根据本规范，DTO的字段注释应该包含哪些内容？"
- **代码片段合规性检查**：可以粘贴少量代码片段，并要求AI基于本规范的具体章节或条款进行快速检查。例如："帮我看看这段代码的日志打印是否符合 `@java-code-development-and-quality.mdc` 的日志规范？"，或者在重构时："这段旧代码在事务处理方面有哪些不符合本规范的地方，应该如何修改？"
- **最佳实践建议**：针对特定场景，可以询问AI在本规范框架下的推荐做法。例如："我需要在BizServiceImpl中处理一个可能调用多个DAO操作的业务逻辑，并确保整体事务性，根据规范，推荐使用声明式事务还是编程式事务？如果是编程式，规范中推荐哪种方式？"

### 5.3 引导AI产出合规的高质量代码
- **明确的、基于规范的指令**：在要求AI生成代码时（如创建新的Controller、Service、DAO、DTO或工具类），指令中应明确包含需遵循的规范要点。例如："请帮我创建一个名为`ProductServiceImpl`的类。它应位于`biz`模块。在确定其具体包路径时，请**严格遵循** `@java-project-architecture-and-structure.mdc` 中定义的项目包结构规范，该规范通常要求在项目基础包名（如 `com.hexonal.{项目标识}`）下，根据模块类型（如 `biz`）和具体业务模块（如 `{模块}`）来组织，形成类似 `com.hexonal.{项目标识}.biz.{模块}.service.impl` 的结构。请确保将占位符 `{项目标识}` 和 `{模块}` 替换为当前项目的实际名称。同时，确保使用构造器注入，类和方法注释完整，所有类名、方法名、变量名均严格遵守 `@java-code-development-and-quality.mdc` 中的命名规范，并遵循本规范中关于Service层方法设计（参数校验、业务处理、结果处理分层）的要求。"
- **结构化代码生成**：对于需要遵循特定结构的代码（如`XxxServiceImpl`的模板、符合`@java-code-development-and-quality.mdc`命名规范的`XxxReq`/`XxxResp`的字段定义、单元测试类的骨架），可以要求AI直接生成符合规范的框架代码，然后开发者再填充具体的业务逻辑。
- **合规性重构辅助**：当发现现有代码不符合规范时，可以向AI描述问题并引用相关规范条款（例如 `@java-code-development-and-quality.mdc` 中关于命名或异常处理的规定），要求其提供重构建议或直接生成重构后的代码。例如："这段代码的异常处理不符合 `@java-code-development-and-quality.mdc` 中关于异常转换和日志记录的要求，请帮我重构它，确保所有类和方法名都符合驼峰命名法。"

### 5.4 AI辅助的代码质量保障与提升
- **初步代码审查助手**：在提交代码进行人工Code Review之前，可以先让AI基于本规范进行一轮预审查。AI可以帮助识别一些较为明显的规范偏离点，如命名不规范、注释缺失、未使用推荐的注解、魔法值使用、过于复杂的表达式等。
- **单元测试用例生成与优化**：可以要求AI为特定的方法或类生成符合本规范（如测试方法命名、断言使用、边界条件考虑）的单元测试用例。也可以让AI分析现有测试用例，看是否覆盖了所有重要分支和异常路径，并提出优化建议。
- **识别潜在的代码坏味道**：虽然AI可能无法完全替代资深开发者的判断，但可以引导其识别一些常见的代码坏味道，如方法过长、参数过多、重复代码等，并结合规范给出初步的优化方向。

### 5.5 与AI协作的持续学习与反馈闭环
- **将AI反馈视为学习机会**：当AI基于规范指出代码问题或提出改进建议时，开发者应将其视为一次加深规范理解和提升编码技能的机会。
- **用规范校准AI**：如果AI生成的代码不完全符合本规范，开发者应进行修正，并可以将修正前后的对比和规范要点反馈给AI（如果AI支持此类学习交互），或者至少在后续提问中更精确地引导AI。这种互动有助于AI更好地适应项目的编码标准。
- **共同演进规范与实践**：在与AI协作编码的过程中，如果发现某些规范条款在AI辅助下难以高效执行，或者AI的某些建议超出了当前规范但确实更优，可以作为讨论和修订规范的输入，促进规范与AI辅助开发实践的共同进步。

## 六、领域驱动设计（DDD）与充血模型实践 (变种DDD)

本章节旨在指导如何在现有Java项目规范体系下，有效地融合领域驱动设计（DDD）的核心思想，特别是充血模型，以构建更具业务表达力、可维护性和扩展性的系统。这是一种结合实际情况的、务实的DDD实践方式。

### 6.1 核心理念：业务逻辑向领域模型内聚
1.  **充血的领域实体 (Rich Domain Entity)**：
    *   领域实体不仅仅是数据的容器，更要封装属于自身的业务行为和规则。例如，一个 `Order` 实体应该有 `cancel()`、`confirmPayment()`、`addItem()` 等方法，这些方法直接修改订单自身的状态或数据。
    *   **优先将业务逻辑放在最能体现其本质的领域实体中**。
2.  **应用服务 (Application Service) 的职责**：
    *   应用服务（通常是 `XxxServiceImpl` 或 `XxxAppServiceImpl`）是领域模型的直接客户。
    *   **主要职责**：
        *   **用例协调**：接收外部请求（如Controller的调用），加载相关的领域实体（通过Repository），调用实体的方法来执行业务逻辑。
        *   **事务管理**：控制业务用例的事务边界。
        *   **权限校验**：执行必要的安全检查。
        *   **与外部系统交互**：如发送通知、调用其他微服务（通过防腐层）。
        *   **DTO转换**：负责领域对象与DTO之间的转换，向外部屏蔽领域模型的复杂性。
    *   **避免**：应用服务不应包含核心的、属于某个特定实体的业务规则判断或状态变更逻辑。这些应在实体内部。
3.  **领域服务 (Domain Service)**：
    *   当某项业务逻辑不适合放在任何一个单一的实体或值对象中时（例如，它需要协调多个实体，或者它代表了一个重要的领域过程），可以使用领域服务。
    *   领域服务的方法通常接收领域对象作为参数。
    *   例如，一个复杂的订单价格计算规则，如果涉及多种促销策略和用户等级，可以由 `OrderPricingDomainService` 来实现。
4.  **仓库 (Repository)**：
    *   负责领域对象的持久化和检索，提供一个类似集合的接口来操作聚合根（Aggregate Root）。
    *   将领域模型与具体的持久化技术（如MyBatis, JPA）解耦。
    *   Repository 的接口定义在领域层，其实现通常放在基础设施层（或DAO层）。
    *   负责领域实体 (`XxxEntity`) 与数据持久化对象 (`XxxDO`) 之间的映射转换。

### 6.2 变种DDD的特点与协调
1.  **现有规范的继承与演进**：
    *   本DDD实践是在现有 `@java-code-development-and-quality.mdc`、`@java-project-architecture-and-structure.mdc` 等规范基础上的增强，不是完全颠覆。
    *   **命名规范**：在现有命名规则基础上，引入DDD特有的构件命名（如 `XxxEntity`, `XxxRepository`, `XxxDomainService`），并明确其在DDD分层架构中的角色。原有的 `XxxDO` 继续作为数据持久化对象，`XxxService` 可演进为应用服务 `XxxAppService`。
    *   **分层架构**：DDD的分层架构（表示层、应用层、领域层、基础设施层）可以与现有的模块划分（web, biz, dao等）进行映射和对应。
        *   `web` 模块通常对应表示层。
        *   `biz` 模块可以包含应用层和部分领域层逻辑（特别是应用服务和领域服务接口）。
        *   领域实体和值对象可以放在 `biz` 模块下的特定领域包中，或者一个独立的 `domain` 模块（如果项目复杂）。
        *   `dao` 模块或一个独立的 `infrastructure` 模块可以包含Repository的实现和DO的定义。
2.  **DO 与 Entity 的关系**：
    *   `XxxDO` (Data Object)：贫血对象，与数据库表结构一一对应，由MyBatis-Plus管理，主要用于数据持久化。
    *   `XxxEntity` (Domain Entity)：充血对象，包含业务逻辑和状态，是领域模型的核心。
    *   `XxxRepository` 负责 `XxxEntity` 和 `XxxDO` 之间的转换。应用服务通过Repository获取 `XxxEntity`，操作实体后，再通过Repository持久化（通常会转换为DO）。
3.  **事务管理**：
    *   事务依然推荐使用 `@Transactional` 注解，通常标记在应用服务的方法上，确保一个完整的业务用例在一个事务中执行。
4.  **代码组织**：
    *   在 `biz` 模块（或独立的 `domain` 模块）中，按限界上下文（Bounded Context）或核心领域概念组织包结构。例如：
        ```
        com.hexonal.ht.biz.oms // 订单管理上下文
          ├── domain
          │   ├── model      // 实体、值对象
          │   │   ├── order
          │   │   │   ├── Order.java  (Entity - Aggregate Root)
          │   │   │   ├── OrderItem.java (Entity)
          │   │   │   ├── ShippingAddress.java (Value Object)
          │   │   │   └── OrderStatus.java (Enum)
          │   │   └── product
          │   │       └── ProductSnapshot.java (Value Object or Entity representing product info at time of order)
          │   ├── service    // 领域服务接口与实现
          │   │   └── OrderPricingDomainService.java
          │   └── repository // Repository接口
          │       └── OrderRepository.java
          ├── application    // 应用服务
          │   ├── OrderAppService.java
          │   ├── impl
          │   │   └── OrderAppServiceImpl.java
          │   └── dto
          │       ├── CreateOrderReq.java
          │       └── OrderDetailsResp.java
          └── // ... 其他如定时任务、消息处理等
        ```
5.  **逐步演进**：
    *   对于现有项目，不必追求一次性完全DDD改造。可以从核心领域、业务复杂性高的模块开始试点，逐步引入充血模型和DDD思想。
    *   新项目或新模块则推荐从一开始就采用这种变种DDD架构。

### 6.3 实践DDD的收益与考量
1.  **收益**：
    *   **更清晰的业务表达**：代码结构更贴近业务语言，降低沟通成本。
    *   **更高的内聚性**：业务逻辑和其操作的数据被封装在一起，易于理解和修改。
    *   **更低的耦合度**：通过明确的接口和分层，降低模块间的依赖。
    *   **更好的可测试性**：领域实体和领域服务通常不依赖外部框架，易于进行单元测试。
    *   **更强的可扩展性**：清晰的边界和内聚的模块使得系统更容易适应变化。
2.  **考量**：
    *   **学习曲线**：团队需要理解DDD的核心概念和思想。
    *   **设计复杂度**：初期可能需要更多的时间进行领域建模和设计。
    *   **过度设计风险**：对于简单的CRUD操作，不必强行套用所有DDD模式，应务实选择。的变种DDD允许在简单场景下仍可使用贫血模型和事务脚本模式。
    *   **性能**：充血模型中实体方法调用可能涉及数据库操作，需关注性能，尤其是在Repository的实现和实体间关联加载策略上。

### 6.4 与AI协作实践DDD
*   **模型构建辅助**：可以向AI描述业务场景，要求其初步识别潜在的实体、值对象、聚合等，并讨论其合理性。
*   **行为分配**：在设计实体方法时，可以与AI讨论某个业务逻辑应该属于哪个实体，或者是否需要一个领域服务。
*   **代码生成**：在明确了实体及其行为后，可以要求AI生成符合充血模型特点的实体类骨架（包含字段和业务方法签名），并遵循本规范中的命名和注释约定。
*   **Repository模式实现**：可以要求AI生成Repository接口及其基于MyBatis-Plus的实现骨架，包括Entity与DO的转换逻辑。
*   **规范检查**：提供代码片段，询问AI是否符合充血模型原则或本规范中关于DDD的特定要求。

---

## 五、AI辅助编码与规范融合实践