---
description: 
globs: 
alwaysApply: true
---
# Java项目代码开发与质量规范

本规范旨在统一Java项目的代码编写风格、质量标准、测试要求和提交过程，以确保代码的健壮性、可读性和可维护性。

## 一、代码编写规范

### 【强制】方法设计原则
1. 原子性原则：
   - 一个方法只做一件事情
   - 方法的功能必须具有原子性，不可再分
   - 避免在一个方法中混合多个业务逻辑
   - 修改操作必须保证事务的原子性
   - **【项目适配】**：如果项目使用充血模型，领域实体应封装自身的业务行为，避免将实体行为放在Service层

2. 可读性原则：
   - 方法名必须清晰表达其功能
   - 参数命名必须见名知意
   - 复杂逻辑必须添加注释说明
   - 避免使用魔法数字，应该使用常量定义

3. 分层原则：
   ```java
   @Service
   @RequiredArgsConstructor  // 使用构造器注入
   public class XxxBizServiceImpl implements XxxBizService {
       // 注入依赖
       private final XxxRpcProxyService xxxRpcProxyService;

       @Override
       public void doSomething(XxxReq req) {
           // 1. 参数校验
           validateParams(req);

           // 2. 业务处理
           xxxRpcProxyService.doSomething(req);

           // 3. 结果处理（如果需要）
           handleResult();
       }
   }
   ```

### 【强制】业务代码规范
1. 服务实现类：
   - 必须使用 @Service 注解
   - 必须使用 @RequiredArgsConstructor 进行依赖注入
   - 必须实现对应的接口
   - 类名必须以 ServiceImpl 或 BizServiceImpl 结尾
   - **【项目适配】**：如果项目使用DDD架构，应用服务主要负责编排领域对象，处理事务和安全等，核心业务逻辑应在领域层

2. 方法实现：
   - 必须添加 @Override 注解
   - 必须进行参数校验
   - 必须处理异常情况
   - 必须记录关键日志

3. 事务处理：
   ```java
   @Transactional(rollbackFor = Exception.class)
   public void updateData(XxxReq req) {
       // 1. 数据校验
       validateData(req);

       // 2. 更新操作
       doUpdate(req);

       // 3. 结果处理
       handleResult();
   }
   ```

4. 手动事务处理规范：
   在需要更细粒度控制或特定场景下，可以考虑手动管理事务。但优先推荐使用Spring的编程式事务管理（如`TransactionTemplate`）。若直接使用JDBC进行手动事务管理，必须遵循以下规范：

   a. **适用场景**：
      - 事务边界无法简单通过 `@Transactional` 定义在方法级别时。
      - 需要在一个业务方法内执行多个独立的、需要精细控制的事务单元。
      - 与某些不支持Spring声明式事务的特定组件交互，且该组件自身提供事务API时。

   b. **【强制】获取与释放资源**：
      - 数据库连接必须通过依赖注入的 `DataSource` 的 `getConnection()` 方法获取。
      - 必须在 `finally` 块中确保 `Connection`、`Statement`、`ResultSet` 等资源被正确关闭，即使发生异常。顺序为：先 `ResultSet`，再 `Statement`，最后 `Connection`。
      - 强烈推荐使用 `try-with-resources` 语句（Java 7+）自动管理资源，以简化代码并减少遗漏关闭的风险。
        ```java
        // 推荐使用 try-with-resources
        try (Connection conn = dataSource.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(SQL_XXX)) {
            // ... 设置参数并执行
        } catch (SQLException e) {
            // ... 处理异常
        }
        ```

   c. **【强制】事务边界显式控制**：
      - 在开启事务前，必须调用 `connection.setAutoCommit(false);`。
      - 业务逻辑成功完成后，必须调用 `connection.commit();` 提交事务。
      - 当发生 `SQLException` 或业务逻辑判断需要回滚时，必须在 `catch` 块或相应逻辑中调用 `connection.rollback();`。
      - 示例结构：
        ```java
        Connection conn = null;
        try {
            conn = dataSource.getConnection();
            conn.setAutoCommit(false); // 开始事务

            // ... 执行数据库操作1
            // ... 执行数据库操作2

            conn.commit(); // 提交事务
        } catch (SQLException e) {
            if (conn != null) {
                try {
                    conn.rollback(); // 回滚事务
                } catch (SQLException ex) {
                    // 记录回滚失败的日志，参考 [java-error-handling-and-operations.mdc](mdc:.cursor/rules/java-error-handling-and-operations.mdc) 日志规范
                    log.error("Transaction rollback failed", ex);
                }
            }
            // 将SQLException转换为项目定义的业务异常，具体异常类和错误码请参考项目的异常处理规范
            // 示例：throw new ProjectBizException(PROJECT_ERROR_CODE.DATABASE_OPERATION_FAILED, "Database operation failed: " + e.getMessage(), e);
        } finally {
            if (conn != null) {
                try {
                    conn.setAutoCommit(true); // 恢复自动提交（可选，取决于连接池配置和后续使用）
                    conn.close(); // 关闭连接（归还到连接池）
                } catch (SQLException e) {
                    log.error("Failed to close connection", e);
                }
            }
        }
        ```

   d. **【强制】异常处理与日志**：
      - 所有 `SQLException` 都必须被捕获。
      - 捕获异常后，如果事务需要回滚，则执行回滚操作。
      - 必须记录详细的错误日志，包含错误信息、堆栈、可能的业务上下文，遵循 [java-error-handling-and-operations.mdc](mdc:.cursor/rules/java-error-handling-and-operations.mdc) 的日志规范。
      - 最终应将底层的 `SQLException` (以及其他受检查异常或特定的运行时异常) 包装成或转换为项目定义的业务异常 (携带合适的错误码) 向上抛出，遵循项目的异常处理规范。对于无法归类的、非预期的运行时故障，可按规范使用系统异常。

   e. **【推荐】Spring编程式事务**：
      - **优先推荐**：即使需要手动控制事务的执行点，也应优先考虑使用Spring提供的 `TransactionTemplate`。它简化了手动事务管理的复杂性，减少了样板代码，并能更好地集成Spring的事务同步和资源管理机制。
      2
      - `TransactionTemplate` 示例:
        ```java
        // import 项目定义的异常类和错误码枚举
        @Autowired
        private TransactionTemplate transactionTemplate;
        // 可以注入其他需要在此事务中操作的Service或DAO组件，例如:
        // @Autowired
        // private YourCustomService yourCustomService;
        // @Autowired
        // private YourCustomDao yourCustomDao;

        public void doSomethingInTransaction() {
            transactionTemplate.execute(status -> {
                try {
                    // 执行数据库操作1 (例如通过注入的Service/DAO):
                    // yourCustomService.doWork1();
                    // yourCustomDao.updateData1();
                    // log.info("执行数据库操作1完成");

                    // 执行数据库操作2 (例如通过注入的Service/DAO):
                    // yourCustomService.doWork2();
                    // yourCustomDao.updateData2();
                    // log.info("执行数据库操作2完成");

                    // 如果没有异常，事务会自动提交
                    return null; // 或返回一个结果，如果方法签名是 TransactionCallback<T>
                } catch (DataAccessException e) { // Spring的通用数据访问异常
                    status.setRollbackOnly(); // 标记事务为仅回滚
                    log.error("Transaction failed due to DataAccessException, rolling back.", e);
                    // 将DataAccessException转换为项目定义的业务异常，具体异常类和错误码请参考项目的异常处理规范
                    // 示例：throw new ProjectBizException(PROJECT_ERROR_CODE.TRANSACTION_FAILED_DATA_ACCESS, "Operation failed within transaction due to DataAccessException", e);
                } catch (Exception e) { // 可根据需要捕获更具体的业务异常或检查型异常
                    status.setRollbackOnly();
                    log.error("Transaction failed due to an unexpected exception, rolling back.", e);
                    // 转换为项目定义的业务异常，具体异常类和错误码请参考项目的异常处理规范
                    // 示例：throw new ProjectBizException(PROJECT_ERROR_CODE.TRANSACTION_FAILED_UNEXPECTED, "Operation failed unexpectedly within transaction", e);
                }
            });
        }
        ```
      - 如果需要更底层的控制，可以直接注入 `PlatformTransactionManager` (例如 `DataSourceTransactionManager`)，并使用 `TransactionDefinition` 和 `TransactionStatus` 手动开启、提交、回滚事务。这种方式比直接操作JDBC Connection更安全，但比 `TransactionTemplate` 复杂。

   f. **【警告】避免滥用手动事务**：
      - 仅在Spring声明式事务 (`@Transactional`) 确实无法满足需求，且细粒度控制确实必要时才考虑手动事务。
      - 手动事务代码更容易出错（如忘记释放资源、错误处理不当），增加了代码复杂度和维护成本。

   g. **【注意】事务隔离级别与传播行为**：
      - 直接使用JDBC Connection时，可以通过 `connection.setTransactionIsolation(int level)` 设置隔离级别。但需谨慎，不当的隔离级别可能导致数据一致性问题或性能下降。
      - 如果使用Spring编程式事务（`TransactionTemplate`或`PlatformTransactionManager`），可以通过`TransactionDefinition`设置隔离级别和传播行为，其行为与声明式事务类似。

### 【强制】命名规范
1. 类命名：
   - **【项目适配】DDD架构项目的命名规范**：
     - 领域实体：`Xxx` 或 `XxxEntity` (如 `Order`, `UserEntity`)
     - 值对象：`XxxValue` 或描述性名称 (如 `AddressValue`, `Money`)
     - 领域服务：`XxxDomainService` (如 `OrderPricingDomainService`)
     - 应用服务：`XxxAppService` 或保持现有的 `XxxService` / `XxxBizService`
     - 工厂类：`XxxFactory` (如 `OrderFactory`)
     - 仓库接口：`XxxRepository` (如 `OrderRepository`)
   - 数据持久化对象 (DO, Data Object, 与数据库表结构一一对应，用于ORM)：`XxxDO`。**注意：在DDD中，DO主要用于数据持久化，领域实体 (`XxxEntity`) 承载业务逻辑。Repository负责Entity与DO之间的转换。**
   - 数据传输对象 (DTO, Data Transfer Object, 用于应用层与外部（如表示层、RPC调用方）之间的数据传输)：`XxxDTO`。
   - 数据传输rpc传入入参对象: `XxxRpcReq` (可视为一种特定用途的DTO)
   - 数据传输rpc传入出参对象：`XxxRpcResp` (可视为一种特定用途的DTO)
   - 实体类中的get/set方法使用lombok来完成 (适用于DO和DTO，领域实体的方法应具有业务含义，不仅仅是getter/setter)
   - 请求对象：`XxxReq` (通常用于Controller层，可视为一种特定用途的DTO)
   - 响应对象：`XxxResp` (通常用于Controller层，可视为一种特定用途的DTO)
   - dao实体类: `XxxDO`
   - dao关联的myabtis-plus接口: `XxxMapper extends BaseMapper<XxxDO>`
   - dao服务接口：`XxxDAO extends IService<XxxDO>`
   - dao服务实现：`XxxDAOImpl extends ServiceImpl<XxxMapper, XxxDO> implements XxxDAO`
     - **【项目适配】**：DDD项目可使用Repository接口 `XxxRepository`，实现类为 `XxxRepositoryImpl`
   - biz服务接口：`XxxService` (或 `XxxAppService`)
   - biz服务实现：`XxxServiceImpl` (或 `XxxAppServiceImpl`)
   - 控制器：`XxxController`
   - 工具类：`XxxUtils`
   - 操作redis相关的类: `hexonalJedis`
   - 操作分页相关的类: `PageUtils`
   - rpc的接口命名: `XxxRpcService`
   - rpc的接口实现命名: `XxxRpcServiceImpl`
   - rpc调用方接口命名: `XxxRpcProxyService`
   - rpc调用接口实现命名: `XxxRpcProxyServiceImpl`
   - rpc实现统一需要继承: `extends BaseRpcService`
   - 实体类需要实现: `implements Serializable` (DO和DTO通常需要序列化，领域实体按需)
2. 方法命名：
   - **【项目适配】**：如果项目使用充血模型，领域实体的方法应直接体现业务动作，如 `order.cancel()`, `product.applyDiscount()`
   - 获取单个对象：`getXxx` (用于应用服务或仓库) 或 `findXxx` (常用于仓库)
   - 获取多个对象：`listXxx` (用于应用服务或仓库) 或 `findAllXxx` (常用于仓库)
   - 统计数量：`countXxx`
   - 新增：`createXxx` (用于应用服务) 或 `saveXxx` / `addXxx` (常用于仓库)
   - 修改：`updateXxx` (用于应用服务) 或 `saveXxx` (常用于仓库，表示保存状态变更)
   - 删除：`deleteXxx` (用于应用服务或仓库)
   - 分页: `pageXXX`
3. 变量命名：
   - 常量：全大写下划线分隔
   - 变量：驼峰命名
4. 项目代码创建规范,需要根据模块定义: (此条目更偏向项目结构，但为保持完整性暂时保留)
   - xxx-api模块: 提供rpc相关接口
   - xxx-api-impl模块: 实现接口相关实现
   - xxx-biz模块: 业务实现层
   - xxx-common模块: 通用能力
   - xxx-dao模块: 提供数据库交互的原子化能力
   - xxx-integration模块: 提供调用外部调用的能力,如http或者rpc等
   - xxx-web模块： 提供对外暴露的http接口

### 【强制】注释规范
1. 类注释：
   ```java
   /**
    * 类的功能描述（详细说明类的职责、主要功能、使用场景）
    *
    * @author 开发者姓名（智能自动获取）
    * @date yyyy-MM-dd（智能自动获取当前日期）
    * @version 版本号
    */
   ```

   **【智能自动获取规则】**：
   - **Git作者获取优先级**：
     1. 优先使用 `git config user.name` 获取当前Git仓库的提交作者
     2. 如Git配置不存在，使用 `git config --global user.name` 获取全局Git配置
     3. 最后备选使用系统用户名作为默认值
   - **时间自动获取**：
     - 使用系统当前日期，格式严格为 `yyyy-MM-dd`
     - 通过 `date +%Y-%m-%d` 命令或等效方式获取
   - **AI代码生成集成**：
     - 当AI生成Java代码时，自动调用系统命令获取Git作者和当前时间
     - 确保所有生成的类注释使用真实的开发者信息，而非模板变量
     - 支持多平台兼容（Windows/macOS/Linux）

### 【强制】AI智能获取Git信息实现规范
1. **Git作者自动获取实现**：
   ```bash
   # 【重要】必须在项目根目录下执行，确保获取项目特定的Git配置
   cd /path/to/project && git config user.name

   # 或者使用相对路径（如果已在项目目录中）
   git config user.name

   # 备选：获取全局Git配置
   git config --global user.name

   # 示例输出：shizeying
   ```

2. **当前时间自动获取实现**：
   ```bash
   # macOS/Linux
   date +%Y-%m-%d

   # Windows (PowerShell)
   Get-Date -Format "yyyy-MM-dd"

   # 示例输出：2025-06-11
   ```

3. **【关键】项目目录路径要求**：
   - **必须在项目根目录下执行Git命令**：确保获取的是当前项目的Git配置，而非全局或其他项目配置
   - **工作目录检查**：AI在执行命令前应确认当前工作目录为项目根目录
   - **路径切换示例**：如当前不在项目目录，需先切换：`cd /Users/zeyingshi/IdeaProjects/coding && git config user.name`

3. **AI代码生成标准流程**：
   ```java
   // AI生成代码时的标准注释模板示例
   /**
    * 任务处理控制器
    * 提供任务查询、完成、奖励领取等相关接口服务
    *
    * @author shizeying  // 自动从git config user.name获取
    * @date 2025-06-11   // 自动从系统当前日期获取
    * @version 1.0
    */
   ```

4. **实现要求**：
   - **【强制】真实信息**：禁止使用占位符或模板变量，必须使用真实获取的Git作者和时间
   - **【强制】命令执行**：AI必须实际执行系统命令获取信息，不得使用假设或预设值
   - **【强制】路径正确性**：Git命令必须在正确的项目根目录下执行，确保获取项目特定的配置
   - **【强制】格式统一**：日期格式严格使用 `yyyy-MM-dd`，作者名称使用Git配置的真实姓名
   - **【推荐】错误处理**：如果Git信息获取失败，应提供明确的错误信息和备选方案

5. **验证机制**：
   - 生成的代码注释中的@author字段必须与实际Git配置一致
   - 生成的代码注释中的@date字段必须是当前系统日期
   - 支持多次调用时保持信息的实时性和准确性

2. 方法注释：
   ```java
   /**
    * 方法的功能描述（详细说明方法用途、业务逻辑、使用场景）
    *
    * @param 参数名 详细的参数说明，包括数据类型、取值范围、格式要求、业务含义等
    * @return {@link 返回对象类型} 详细的返回值说明，包括返回对象的结构、字段含义、可能的取值、异常情况下的返回值等
    * @throws 异常类型 详细的异常抛出条件、触发场景和处理建议
    * @see 相关类或方法的引用，如相关的业务方法、工具类等
    * @see <a href="链接地址">相关文档或规范</a>
    */
   ```
3. 字段注释：
   ```java
   /**
    * 字段说明
    * @mock 模拟数据（如果需要）
    */
   private String field;
   ```
4. 常量注释：
   ```java
   /**
    * 常量说明
    * 例如：订单状态 - 已支付
    */
   public static final int ORDER_STATUS_PAID = 1;
   ```

### 【强制】代码格式
1. 缩进：4个空格
2. 行宽：最大120字符
3. 花括号：
   - 左花括号不换行
   - 右花括号独占一行
4. 空行：
   - 方法间空一行
   - 逻辑块间空一行
5. 导包：
   - 按类型分组
   - 组间空一行
   - 禁止使用*导入
6. 禁止使用行尾注释

### 【强制】编码实践
1. 异常处理：
   - **【项目适配】**：异常处理应根据项目现有的异常体系进行适配
     * 优先使用项目已定义的异常类（如项目中的 `BizException`、`SystemException` 等）
     * 遵循项目既定的错误码规范和异常分类标准
     * 异常处理的具体规范请参考专门的异常处理规范文档
   - **【基本原则】**：
     * 必须进行适当的异常处理，不能简单忽略或吞掉异常
     * 必须记录关键异常信息到日志系统
     * 禁止在循环中抛出异常
     * 禁止在finally块中抛出异常
2. 日志打印：(部分内容与 hexonal-error-handling.mdc 重叠，后续统一处理)
   - 必须使用Log4j2
   - 必须使用占位符
   - 必须进行日志级别判断
   - 必须包含追踪ID
3. 工具类：
   - 必须私有构造函数
   - 必须使用静态方法
4. 配置加载： (部分内容与 [java-error-handling-and-operations.mdc](mdc:.cursor/rules/java-error-handling-and-operations.mdc) 重叠，后续统一处理)
   - **【条件使用】**：优先检查父pom是否引入Apollo依赖，如已引入则使用Apollo配置中心；否则使用Spring标准配置（@Value、@ConfigurationProperties等）
   - 必须使用@ConfigurationProperties进行类型安全的配置绑定
   - 必须进行配置验证（使用JSR303注解或自定义校验器）
   - **【推荐】**：对于微服务架构，建议统一使用配置中心（Apollo/Nacos）进行配置管理

### 【强制】依赖注入规范
1. 构造器注入：
   - 优先使用构造器注入
   - 使用 @RequiredArgsConstructor 注解
   - final 修饰依赖字段

2. 字段注入：
   - 禁止使用 @Autowired 注解注入字段
   - 禁止使用 @Resource 注解注入字段

3. 方法注入：
   - 只在特殊场景下使用
   - 必须说明使用原因

### 【强制】代码修改范围限制
**核心原则：仅能修改当前对话中明确指定的代码内容，严禁任何未授权的修改、删除或格式变动**

1. **绝对禁止的操作**：
   - **禁止删除任何现有代码**（包括注释、空行、方法、字段、导入语句等）
   - **禁止修改或删除现有注释**（包括行注释、块注释、JavaDoc注释等）
   - **禁止修改代码格式**（包括缩进、换行、空格、花括号位置等）
   - **禁止修改未明确指定的任何代码行**
   - **禁止使用魔法值**（必须使用常量定义或配置文件）
   - **禁止进行"优化"或"美化"等未经授权的改动**
   - **禁止修改文件结构**（包括包路径、文件名、目录结构等）

2. **严格的修改边界**：
   - **只能修改用户在当前对话中明确要求修改的具体代码片段**
   - **禁止修改方法签名**（参数列表、返回类型、方法名、访问修饰符）
   - **禁止修改类声明**（类名、继承关系、实现接口、注解等）
   - **禁止修改字段声明**（字段名、类型、访问修饰符、注解等）
   - **禁止修改导入语句**（除非用户明确要求添加新的import）

3. **内容修改限制**：
   - **只能在明确指定的方法体内部添加或修改业务逻辑代码**
   - **禁止修改现有的依赖注入配置**
   - **禁止修改现有的注解配置**（@Service、@Autowired、@Transactional等）
   - **禁止修改变量名、常量名**（除非用户明确要求重命名）

4. **变更追踪与确认**：
   - **每次修改前必须明确说明将要修改的具体内容和范围**
   - **修改后必须提供完整的变更说明**
   - **如有任何不确定是否可以修改的内容，必须先询问用户确认**
   - **严禁进行任何"顺便"的修改或"相关"的调整**

5. **异常处理与错误恢复**：
   - **如果修改过程中发现任何意外变更，必须立即停止并报告**
   - **禁止删除现有的异常处理逻辑**
   - **禁止修改异常抛出链或日志级别**
   - **如需添加新的异常处理，必须经过用户明确确认**

6. **代码质量保证**：
   - **修改的代码必须保持与现有代码风格一致**
   - **不得引入编译错误或逻辑错误**
   - **必须保持代码的功能完整性和业务逻辑正确性**
   - **如有疑问必须停止修改并询问用户**

**违反此规范的任何修改都将被视为错误操作，必须立即撤销并重新执行。**

### 遵守 SOLID 原则，确保 Spring Boot 应用程序设计的高内聚性和低耦合性。

## 二、代码质量与测试规范

### 【强制】代码质量规范
1. 性能要求：
   - 避免在循环中进行数据库操作
   - 避免在循环中进行远程调用
   - 批量操作必须控制数量
   - 必要时使用缓存优化
   - 代码需要考虑性能问题，避免代码产生一些阻塞性的问题
   - **【项目适配】**：如果项目采用充血模型，需要关注实体方法中的数据库操作性能，避免N+1查询问题

2. 代码组织：
   - 相关的字段放在一起
   - 相关的方法放在一起
   - 公共方法放在前面
   - 私有方法放在后面
   - 增加适当的换行,避免代码都堆这一坨,导致review过乱
   - **【项目适配】**：如果项目使用领域模型，实体类应将相关的业务行为和状态组织在一起

3. 可维护性要求：
   - 代码必须符合阿里巴巴Java开发手册规范
   - 必须处理所有异常情况
   - 必须添加必要的注释



## 三、代码修改边界与稳定性规范

本章节旨在定义代码修改的基本原则和边界，以保障系统的稳定性和可维护性，减少因修改引入的潜在风险。

### 【核心原则】最小化影响与职责单一
1.  **职责边界清晰**：
    *   每个模块、服务或组件都应有明确定义的职责。
    *   代码修改应严格限制在当前模块或组件的职责边界内，避免随意修改或依赖其他不相关模块的内部实现。
    *   修改前需充分理解模块的既定职责和与其他模块的协定。

2.  **影响范围评估**：
    *   任何修改前，必须评估其潜在影响范围，包括对上游调用者、下游依赖方以及系统整体性能和稳定性的影响。
    *   对于影响较大的修改，需要制定详细的方案、回滚计划，并进行充分的沟通。

### 【强制】接口与契约稳定性
1.  **对外接口（HTTP API / RPC API）**：
    *   **优先扩展**：对于已发布的接口，当需要增加功能或改变行为时，应优先考虑新增接口或在现有接口上新增方法（如果协议支持且不破坏兼容性），而非直接修改原有接口签名或核心行为。
    *   **废弃策略**：旧接口或方法在有替代方案后，应标记为 `@Deprecated`，提供明确的迁移指南和废弃时间表，并通知所有已知调用方。
    *   **兼容性**：任何对接口的修改（如参数增减、类型变更、返回值结构调整、核心业务逻辑变更）都必须经过严格的兼容性评估。不兼容的修改需要上升版本号（参考 [java-project-architecture-and-structure.mdc](mdc:.cursor/rules/java-project-architecture-and-structure.mdc) 中的版本管理规范），并与所有依赖方协调升级。
    *   接口行为的修改（即使签名不变）也需谨慎，确保符合接口文档和调用方预期。

2.  **内部公共方法/类库**：
    *   作为内部共享的工具类、基础服务或公共组件，其公共方法和类定义也应保持高度稳定性。
    *   修改这些公共部分前，必须评估对项目内所有使用方的影响。
    *   修改原则同对外接口，优先保证向后兼容。

### 【推荐】通过配置与扩展点适应变化
1.  **配置驱动**：对于易变的业务规则、阈值、开关等，应优先通过外部配置文件（如 `.properties`, `.yml`）或配置中心进行管理，避免硬编码在代码中。
2.  **扩展点设计**：在核心流程中，对可能发生变化或需要定制化的部分，可以预留清晰的扩展点（如策略模式、模板方法、事件监听、插件机制），使得新功能的增加或行为的调整可以通过实现扩展接口而非修改核心代码来完成。

### 【强制】公共组件与基础框架的修改
1.  **严格控制**：对公司级共享的基础组件、框架（如 `yp-commons` 等）的修改，必须遵循更严格的审批流程和代码审查标准。
2.  **充分测试与通知**：修改后必须进行全面的回归测试和兼容性测试，确保不会对现有业务产生负面影响。发布新版本后，需及时通知所有依赖的项目团队。



### 【强制】遵循版本控制与分支策略
1.  **分支操作**：所有代码修改必须在独立的特性分支或修复分支上进行，严禁直接向主干分支（如 `master` 或 `main`）推送未经评审和测试的代码。
2.  **合并流程**：分支合并回主干前，必须通过代码审查 (Code Review) 和所有自动化测试。
3.  **提交信息**：遵循项目既定的提交信息规范（参考本文档"代码提交规范"部分）。

### 【强制】文档同步
1.  **及时更新**：代码修改后，如果涉及到架构设计、接口定义、重要业务逻辑、配置项等，相关的设计文档、API文档（如Swagger）、README、注释等必须同步更新。
2.  **变更记录**：对于重要的接口或功能变更，建议在文档中保留清晰的变更历史记录。
3.  **【项目适配】架构图与模型图**：DDD项目的技术方案文档中，推荐使用 Mermaid 语法绘制领域模型图、限界上下文映射图等


