---
description: 
globs: 
alwaysApply: false
---
---
description: Java创建型设计模式精细化应用规范
globs: 
alwaysApply: true
---

# Java创建型设计模式精细化应用规范

本规范提供创建型设计模式（工厂模式、建造者模式、单例模式）的精细化应用指导，确保对象创建过程的规范性和可维护性。

## 一、工厂模式精细化规范

### 【强制】工厂模式适用场景识别
```
提示词：@codebase 检查以下场景是否适合使用工厂模式：
1. 对象创建需要5个以上参数
2. 创建过程需要调用3个以上外部服务
3. 创建逻辑包含复杂的业务规则校验
4. 同一类型对象有3种以上创建方式

如果满足2个以上条件，推荐使用工厂模式
```

### 【强制】工厂模式实现规范
1. **工厂类结构规范**：
   ```java
   // 基于项目现有工厂模式分析
   // 提示词：@codebase 分析现有Factory类，确保新工厂遵循相同结构
   
   @Component  // 必须使用Spring管理
   @RequiredArgsConstructor  // 必须使用构造器注入
   public class OrderFactory {
       
       // 【强制】依赖注入 - 必须为final
       private final ProductRepository productRepository;
       private final PricingService pricingService;
       
       // 【强制】主要创建方法命名规范：create + 对象名
       public Order createOrder(CreateOrderCommand command) {
           // 【强制】方法结构必须包含以下步骤：
           validateCommand(command);           // 1. 参数校验
           List<OrderItem> items = createOrderItems(command.getItems());  // 2. 子对象创建
           Money totalAmount = calculateTotal(items);  // 3. 业务计算
           return buildOrder(command, items, totalAmount);  // 4. 对象组装
       }
       
       // 【强制】私有方法必须按职责分离
       private void validateCommand(CreateOrderCommand command) {
           if (command == null || command.getUserId() == null) {
               throw new ProjectBizException(ErrorCode.INVALID_PARAMETER, "订单创建参数不能为空");
           }
           // 具体校验逻辑
       }
       
       private List<OrderItem> createOrderItems(List<CreateOrderItemCommand> itemCommands) {
           return itemCommands.stream()
                   .map(this::createSingleOrderItem)
                   .collect(Collectors.toList());
       }
       
       private OrderItem createSingleOrderItem(CreateOrderItemCommand itemCommand) {
           Product product = productRepository.findById(itemCommand.getProductId())
                   .orElseThrow(() -> new ProjectBizException(ErrorCode.PRODUCT_NOT_FOUND));
           return new OrderItem(product, itemCommand.getQuantity());
       }
       
       private Money calculateTotal(List<OrderItem> items) {
           return pricingService.calculateTotalPrice(items);
       }
       
       private Order buildOrder(CreateOrderCommand command, List<OrderItem> items, Money totalAmount) {
           return Order.builder()
                   .userId(command.getUserId())
                   .items(items)
                   .totalAmount(totalAmount)
                   .status(OrderStatus.PENDING_PAYMENT)
                   .build();
       }
   }
   ```

2. **工厂方法返回值规范**：
   - 【强制】必须返回领域对象，不能返回DTO
   - 【强制】返回对象必须是完整的、可用的业务对象
   - 【强制】不能返回半成品对象，需要调用者继续组装

## 二、建造者模式精细化规范

### 【强制】建造者模式适用场景
```
提示词：@codebase 检查以下场景是否需要使用建造者模式：
1. 对象有10个以上属性
2. 对象创建有多个可选参数
3. 对象创建需要分步骤进行
4. 需要创建不可变对象

如果满足2个以上条件，推荐使用建造者模式
```

### 【强制】建造者实现规范
1. **建造者类设计**：
   ```java
   // 【强制】建造者必须是目标类的静态内部类
   public class ComplexOrder {
       // 【强制】所有字段必须为final（不可变对象）
       private final String orderId;
       private final String userId;
       private final List<OrderItem> items;
       private final Money totalAmount;
       private final ShippingAddress shippingAddress;
       private final PaymentMethod paymentMethod;
       private final List<Coupon> coupons;
       private final OrderMetadata metadata;
       
       // 【强制】私有构造器，只能通过Builder创建
       private ComplexOrder(Builder builder) {
           this.orderId = builder.orderId;
           this.userId = builder.userId;
           this.items = Collections.unmodifiableList(builder.items);
           this.totalAmount = builder.totalAmount;
           this.shippingAddress = builder.shippingAddress;
           this.paymentMethod = builder.paymentMethod;
           this.coupons = Collections.unmodifiableList(builder.coupons);
           this.metadata = builder.metadata;
       }
       
       // 【强制】提供静态方法创建Builder
       public static Builder builder() {
           return new Builder();
       }
       
       // 【强制】Builder必须是静态内部类
       public static class Builder {
           // 【强制】必填字段在构造时检查
           private String orderId;
           private String userId;
           private List<OrderItem> items = new ArrayList<>();
           
           // 【强制】可选字段提供默认值
           private Money totalAmount = Money.ZERO;
           private ShippingAddress shippingAddress;
           private PaymentMethod paymentMethod;
           private List<Coupon> coupons = new ArrayList<>();
           private OrderMetadata metadata = new OrderMetadata();
           
           // 【强制】必填字段的setter方法
           public Builder orderId(String orderId) {
               this.orderId = orderId;
               return this;
           }
           
           public Builder userId(String userId) {
               this.userId = userId;
               return this;
           }
           
           public Builder addItem(OrderItem item) {
               this.items.add(item);
               return this;
           }
           
           public Builder items(List<OrderItem> items) {
               this.items = new ArrayList<>(items);
               return this;
           }
           
           // 【强制】可选字段的setter方法
           public Builder totalAmount(Money totalAmount) {
               this.totalAmount = totalAmount;
               return this;
           }
           
           public Builder shippingAddress(ShippingAddress shippingAddress) {
               this.shippingAddress = shippingAddress;
               return this;
           }
           
           public Builder paymentMethod(PaymentMethod paymentMethod) {
               this.paymentMethod = paymentMethod;
               return this;
           }
           
           public Builder addCoupon(Coupon coupon) {
               this.coupons.add(coupon);
               return this;
           }
           
           public Builder metadata(OrderMetadata metadata) {
               this.metadata = metadata;
               return this;
           }
           
           // 【强制】build方法必须进行完整性校验
           public ComplexOrder build() {
               validateRequiredFields();
               validateBusinessRules();
               return new ComplexOrder(this);
           }
           
           private void validateRequiredFields() {
               if (orderId == null || orderId.trim().isEmpty()) {
                   throw new ProjectBizException(ErrorCode.INVALID_PARAMETER, "订单ID不能为空");
               }
               if (userId == null || userId.trim().isEmpty()) {
                   throw new ProjectBizException(ErrorCode.INVALID_PARAMETER, "用户ID不能为空");
               }
               if (items.isEmpty()) {
                   throw new ProjectBizException(ErrorCode.INVALID_PARAMETER, "订单项不能为空");
               }
           }
           
           private void validateBusinessRules() {
               // 业务规则校验
               if (totalAmount.isNegative()) {
                   throw new ProjectBizException(ErrorCode.INVALID_PARAMETER, "订单金额不能为负数");
               }
           }
       }
   }
   ```

## 三、单例模式精细化规范

### 【强制】单例模式适用场景
```
提示词：@codebase 检查以下场景是否需要使用单例模式：
1. 全局配置管理器
2. 线程池管理器
3. 缓存管理器
4. 日志管理器

注意：在Spring环境中，优先使用@Component单例，避免手动实现单例
```

### 【强制】单例实现规范
1. **Spring管理的单例（推荐）**：
   ```java
   // 【推荐】使用Spring管理单例
   @Component
   @Scope("singleton")  // 默认就是单例，可以省略
   public class ConfigurationManager {
       
       private final Map<String, String> configurations = new ConcurrentHashMap<>();
       
       public String getConfiguration(String key) {
           return configurations.get(key);
       }
       
       public void setConfiguration(String key, String value) {
           configurations.put(key, value);
       }
   }
   ```

2. **手动实现单例（特殊场景）**：
   ```java
   // 【强制】使用枚举实现单例（推荐方式）
   public enum GlobalConfigManager {
       INSTANCE;
       
       private final Map<String, String> configurations = new ConcurrentHashMap<>();
       
       public String getConfiguration(String key) {
           return configurations.get(key);
       }
       
       public void setConfiguration(String key, String value) {
           configurations.put(key, value);
       }
   }
   
   // 【强制】如果必须使用类实现，使用双重检查锁定
   public class ThreadSafeConfigManager {
       private static volatile ThreadSafeConfigManager instance;
       private final Map<String, String> configurations;
       
       private ThreadSafeConfigManager() {
           this.configurations = new ConcurrentHashMap<>();
       }
       
       public static ThreadSafeConfigManager getInstance() {
           if (instance == null) {
               synchronized (ThreadSafeConfigManager.class) {
                   if (instance == null) {
                       instance = new ThreadSafeConfigManager();
                   }
               }
           }
           return instance;
       }
       
       public String getConfiguration(String key) {
           return configurations.get(key);
       }
       
       public void setConfiguration(String key, String value) {
           configurations.put(key, value);
       }
   }
   ```

3. **单例使用规范**：
   - 【强制】优先使用Spring的@Component管理单例
   - 【强制】如果必须手动实现，优先使用枚举方式
   - 【强制】避免在单例中持有可变的全局状态
   - 【强制】单例类必须是线程安全的
