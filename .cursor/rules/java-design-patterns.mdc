---
description: 
globs: 
alwaysApply: true
---
# Java项目设计模式精细化应用规范

本规范提供精细化、明确的设计模式应用指导，通过Cursor代码库索引技术，基于项目现有模式提供具体的实现规范和约束规则。

## 一、设计模式应用原则与约束

### 【强制】设计模式引入条件
1. **必须满足以下条件之一才可引入设计模式**：
   ```
   提示词：@codebase 分析这段代码是否满足设计模式引入条件：
   1. 存在3个以上相似的实现类或方法
   2. 业务逻辑存在明确的变化点和扩展需求
   3. 现有if-else分支超过5个且逻辑复杂
   4. 对象创建过程复杂且需要多步骤验证
   5. 需要解耦具体实现与接口调用
   ```

2. **禁止过度设计**：
   - 禁止为了使用设计模式而设计模式
   - 禁止在简单场景中引入复杂模式
   - 禁止同时使用多个设计模式导致过度抽象

### 【强制】设计模式命名规范
1. **工厂类命名**：`业务名称 + Factory`
   - 正确：`OrderFactory`、`UserFactory`、`PaymentFactory`
   - 错误：`CreateOrder`、`OrderCreator`、`OrderBuilder`（Builder是另一种模式）

2. **策略类命名**：`具体策略描述 + Strategy`
   - 正确：`FixedAmountDiscountStrategy`、`PercentageDiscountStrategy`
   - 错误：`DiscountHandler`、`DiscountProcessor`、`DiscountService`

3. **适配器类命名**：`外部系统名称 + Adapter`
   - 正确：`AlipayPaymentAdapter`、`WechatPaymentAdapter`
   - 错误：`PaymentIntegration`、`PaymentGateway`

## 二、工厂模式精细化规范

### 【强制】工厂模式适用场景识别
```
提示词：@codebase 检查以下场景是否适合使用工厂模式：
1. 对象创建需要5个以上参数
2. 创建过程需要调用3个以上外部服务
3. 创建逻辑包含复杂的业务规则校验
4. 同一类型对象有3种以上创建方式

如果满足2个以上条件，推荐使用工厂模式
```

### 【强制】工厂模式实现规范
1. **工厂类结构规范**：
   ```java
   // 基于项目现有工厂模式分析
   // 提示词：@codebase 分析现有Factory类，确保新工厂遵循相同结构
   
   @Component  // 必须使用Spring管理
   @RequiredArgsConstructor  // 必须使用构造器注入
   public class OrderFactory {
       
       // 【强制】依赖注入 - 必须为final
       private final ProductRepository productRepository;
       private final PricingService pricingService;
       
       // 【强制】主要创建方法命名规范：create + 对象名
       public Order createOrder(CreateOrderCommand command) {
           // 【强制】方法结构必须包含以下步骤：
           validateCommand(command);           // 1. 参数校验
           List<OrderItem> items = createOrderItems(command.getItems());  // 2. 子对象创建
           Money totalAmount = calculateTotal(items);  // 3. 业务计算
           return buildOrder(command, items, totalAmount);  // 4. 对象组装
       }
       
       // 【强制】私有方法必须按职责分离
       private void validateCommand(CreateOrderCommand command) {
           if (command == null || command.getUserId() == null) {
               throw new ProjectBizException(ErrorCode.INVALID_PARAMETER, "订单创建参数不能为空");
           }
           // 具体校验逻辑
       }
       
       private List<OrderItem> createOrderItems(List<CreateOrderItemCommand> itemCommands) {
           return itemCommands.stream()
                   .map(this::createSingleOrderItem)
                   .collect(Collectors.toList());
       }
       
       private OrderItem createSingleOrderItem(CreateOrderItemCommand itemCommand) {
           Product product = productRepository.findById(itemCommand.getProductId())
                   .orElseThrow(() -> new ProjectBizException(ErrorCode.PRODUCT_NOT_FOUND));
           return new OrderItem(product, itemCommand.getQuantity());
       }
       
       private Money calculateTotal(List<OrderItem> items) {
           return pricingService.calculateTotalPrice(items);
       }
       
       private Order buildOrder(CreateOrderCommand command, List<OrderItem> items, Money totalAmount) {
           return Order.builder()
                   .userId(command.getUserId())
                   .items(items)
                   .totalAmount(totalAmount)
                   .status(OrderStatus.PENDING_PAYMENT)
                   .build();
       }
   }
   ```

2. **工厂方法返回值规范**：
   - 【强制】必须返回领域对象，不能返回DTO
   - 【强制】返回对象必须是完整的、可用的业务对象
   - 【强制】不能返回半成品对象，需要调用者继续组装

## 三、策略模式精细化规范

### 【强制】策略模式适用场景识别
```
提示词：@codebase 检查以下场景是否适合使用策略模式：
1. 同一个业务行为有3种以上不同算法实现
2. 算法选择逻辑复杂，包含多层if-else判断
3. 不同算法的输入输出格式一致
4. 算法需要在运行时动态选择

如果满足3个以上条件，必须使用策略模式
```

### 【强制】策略模式实现规范
1. **策略接口设计规范**：
   ```java
   // 【强制】策略接口命名：业务行为 + Strategy
   public interface DiscountStrategy {
       
       // 【强制】方法命名：动词 + 业务对象
       Money calculateDiscount(Order order, DiscountContext context);
       
       // 【强制】必须提供策略标识方法
       String getStrategyType();
       
       // 【强制】必须提供适用性检查方法
       boolean isApplicable(Order order, DiscountContext context);
   }
   ```

2. **策略实现类规范**：
   ```java
   // 【强制】实现类命名：具体策略名 + Strategy
   @Component
   public class FixedAmountDiscountStrategy implements DiscountStrategy {
       
       // 【强制】策略类型常量
       public static final String STRATEGY_TYPE = "FIXED_AMOUNT";
       
       @Override
       public Money calculateDiscount(Order order, DiscountContext context) {
           // 【强制】必须先检查适用性
           if (!isApplicable(order, context)) {
               return Money.ZERO;
           }
           
           // 【强制】具体算法实现，必须包含业务规则校验
           BigDecimal orderAmount = order.getTotalAmount().getAmount();
           BigDecimal discountAmount = context.getDiscountAmount();
           
           if (orderAmount.compareTo(context.getMinOrderAmount()) < 0) {
               throw new ProjectBizException(ErrorCode.DISCOUNT_NOT_APPLICABLE, 
                   "订单金额不满足满减条件");
           }
           
           return new Money(discountAmount, order.getTotalAmount().getCurrency());
       }
       
       @Override
       public String getStrategyType() {
           return STRATEGY_TYPE;
       }
       
       @Override
       public boolean isApplicable(Order order, DiscountContext context) {
           return STRATEGY_TYPE.equals(context.getDiscountType()) 
               && order.getTotalAmount().getAmount().compareTo(context.getMinOrderAmount()) >= 0;
       }
   }
   ```

3. **策略管理器规范**：
   ```java
   @Service
   @RequiredArgsConstructor
   public class DiscountStrategyManager {
       
       // 【强制】使用Map管理策略，key为策略类型
       private final Map<String, DiscountStrategy> strategies;
       
       // 【强制】构造器中初始化策略映射
       public DiscountStrategyManager(List<DiscountStrategy> strategyList) {
           this.strategies = strategyList.stream()
                   .collect(Collectors.toMap(
                       DiscountStrategy::getStrategyType,
                       Function.identity()
                   ));
       }
       
       // 【强制】策略选择方法
       public Money applyDiscount(Order order, DiscountContext context) {
           DiscountStrategy strategy = strategies.get(context.getDiscountType());
           if (strategy == null) {
               throw new ProjectBizException(ErrorCode.UNSUPPORTED_DISCOUNT_TYPE, 
                   "不支持的优惠类型: " + context.getDiscountType());
           }
           
           return strategy.calculateDiscount(order, context);
       }
   }
   ```

## 四、适配器模式精细化规范

### 【强制】适配器模式适用场景
```
提示词：@codebase 检查以下场景是否需要使用适配器模式：
1. 集成第三方系统，接口格式不匹配
2. 新老系统对接，数据结构差异较大
3. 多个外部服务提供相同功能但接口不同
4. 需要统一多种数据源的访问方式

如果存在以上场景，必须使用适配器模式
```

### 【强制】适配器实现规范
1. **适配器接口定义**：
   ```java
   // 【强制】内部统一接口，遵循项目业务命名
   public interface PaymentService {
       PaymentResult pay(PaymentRequest request);
       PaymentStatus queryPaymentStatus(String orderId);
       RefundResult refund(RefundRequest request);
   }
   ```

2. **适配器实现类**：
   ```java
   @Service("alipayAdapter")  // 【强制】必须指定Bean名称
   @RequiredArgsConstructor
   public class AlipayPaymentAdapter implements PaymentService {
       
       private final AlipayClient alipayClient;  // 第三方SDK
       
       @Override
       public PaymentResult pay(PaymentRequest request) {
           try {
               // 【强制】第一步：参数校验
               validatePaymentRequest(request);
               
               // 【强制】第二步：数据转换
               AlipayTradeAppPayRequest alipayRequest = convertToAlipayRequest(request);
               
               // 【强制】第三步：调用第三方接口
               AlipayTradeAppPayResponse alipayResponse = alipayClient.execute(alipayRequest);
               
               // 【强制】第四步：结果转换
               return convertToPaymentResult(alipayResponse, request);
               
           } catch (AlipayApiException e) {
               // 【强制】必须转换为项目内部异常
               log.error("支付宝支付调用失败，订单号：{}", request.getOrderId(), e);
               throw new ProjectBizException(ErrorCode.THIRD_PARTY_PAYMENT_FAILED, 
                   "支付宝支付失败: " + e.getErrMsg(), e);
           }
       }
       
       // 【强制】参数校验方法
       private void validatePaymentRequest(PaymentRequest request) {
           if (request == null || StringUtils.isBlank(request.getOrderId())) {
               throw new ProjectBizException(ErrorCode.INVALID_PARAMETER, "支付请求参数无效");
           }
           if (request.getAmount() == null || request.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
               throw new ProjectBizException(ErrorCode.INVALID_PARAMETER, "支付金额无效");
           }
       }
       
       // 【强制】请求转换方法
       private AlipayTradeAppPayRequest convertToAlipayRequest(PaymentRequest request) {
           AlipayTradeAppPayModel model = new AlipayTradeAppPayModel();
           model.setOutTradeNo(request.getOrderId());
           model.setSubject(request.getSubject());
           model.setTotalAmount(request.getAmount().toString());
           model.setProductCode("QUICK_MSECURITY_PAY");
           
           AlipayTradeAppPayRequest alipayRequest = new AlipayTradeAppPayRequest();
           alipayRequest.setBizModel(model);
           alipayRequest.setNotifyUrl(request.getNotifyUrl());
           
           return alipayRequest;
       }
       
       // 【强制】响应转换方法
       private PaymentResult convertToPaymentResult(AlipayTradeAppPayResponse response, PaymentRequest request) {
           if (!response.isSuccess()) {
               throw new ProjectBizException(ErrorCode.THIRD_PARTY_PAYMENT_FAILED, 
                   "支付宝返回失败: " + response.getSubMsg());
           }
           
           return PaymentResult.builder()
                   .orderId(request.getOrderId())
                   .paymentId(response.getTradeNo())
                   .status(PaymentStatus.SUCCESS)
                   .paymentData(response.getBody())
                   .build();
       }
   }
   ```

## 五、建造者模式精细化规范

### 【强制】建造者模式适用场景
```
提示词：@codebase 检查对象创建是否需要建造者模式：
1. 构造参数超过5个
2. 有多个可选参数组合
3. 对象创建需要多个步骤且顺序重要
4. 需要创建不同配置的同类对象

如果满足2个以上条件，推荐使用建造者模式
```

### 【强制】建造者实现规范
1. **Lombok Builder使用规范**：
   ```java
   @Data
   @Builder
   @NoArgsConstructor
   @AllArgsConstructor(access = AccessLevel.PRIVATE)  // 【强制】私有构造器
   public class UserProfile {
       
       // 【强制】必填字段不能有默认值
       @NonNull
       private Long userId;
       
       @NonNull
       private String username;
       
       // 【强制】可选字段必须有默认值
       @Builder.Default
       private String nickname = "";
       
       @Builder.Default
       private String avatar = "default_avatar.png";
       
       @Builder.Default
       private UserStatus status = UserStatus.ACTIVE;
       
       // 【强制】自定义Builder方法用于复杂校验
       public static class UserProfileBuilder {
           public UserProfileBuilder withValidatedEmail(String email) {
               if (!EmailValidator.isValid(email)) {
                   throw new ProjectBizException(ErrorCode.INVALID_EMAIL_FORMAT);
               }
               this.email = email;
               return this;
           }
           
           public UserProfile build() {
               // 【强制】构建前最终校验
               if (userId == null || username == null) {
                   throw new ProjectBizException(ErrorCode.REQUIRED_FIELD_MISSING, 
                       "用户ID和用户名为必填字段");
               }
               return new UserProfile(userId, username, nickname, avatar, status);
           }
       }
   }
   ```

## 六、观察者模式精细化规范

### 【强制】观察者模式实现规范
1. **事件定义规范**：
   ```java
   // 【强制】事件类命名：业务对象 + 业务动作 + Event
   @Data
   @AllArgsConstructor
   public class OrderPaymentSuccessEvent {
       
       // 【强制】必须包含业务标识
       private final Long orderId;
       private final Long userId;
       
       // 【强制】必须包含时间戳
       private final LocalDateTime occurredAt;
       
       // 【强制】必须包含业务数据
       private final Money paymentAmount;
       private final String paymentMethod;
       
       // 【强制】可选的上下文信息
       private final Map<String, Object> eventContext;
   }
   ```

2. **事件发布规范**：
   ```java
   @Service
   @RequiredArgsConstructor
   public class PaymentServiceImpl implements PaymentService {
       
       private final ApplicationEventPublisher eventPublisher;
       
       @Transactional(rollbackFor = Exception.class)
       public void processPayment(PaymentCommand command) {
           // 业务处理...
           
           // 【强制】事件发布必须在事务提交前
           OrderPaymentSuccessEvent event = new OrderPaymentSuccessEvent(
               command.getOrderId(),
               command.getUserId(),
               LocalDateTime.now(),
               command.getAmount(),
               command.getPaymentMethod(),
               buildEventContext(command)
           );
           
           eventPublisher.publishEvent(event);
           
           log.info("支付成功事件已发布，订单号：{}", command.getOrderId());
       }
       
       private Map<String, Object> buildEventContext(PaymentCommand command) {
           Map<String, Object> context = new HashMap<>();
           context.put("source", "PaymentService");
           context.put("version", "1.0");
           return context;
       }
   }
   ```

3. **事件监听规范**：
   ```java
   @Component
   @Slf4j
   public class OrderStatusEventListener {
       
       @EventListener
       @Async("eventTaskExecutor")  // 【强制】异步处理，指定线程池
       @Transactional(propagation = Propagation.REQUIRES_NEW)  // 【强制】新事务
       public void handlePaymentSuccess(OrderPaymentSuccessEvent event) {
           try {
               // 【强制】记录事件处理开始
               log.info("处理支付成功事件，订单号：{}", event.getOrderId());
               
               // 具体业务处理
               updateOrderStatus(event.getOrderId(), OrderStatus.PAID);
               sendPaymentNotification(event.getUserId(), event.getOrderId());
               
               // 【强制】记录事件处理完成
               log.info("支付成功事件处理完成，订单号：{}", event.getOrderId());
               
           } catch (Exception e) {
               // 【强制】异常处理和日志记录
               log.error("处理支付成功事件失败，订单号：{}", event.getOrderId(), e);
               // 【强制】不能抛出异常，避免影响其他监听器
           }
       }
       
       private void updateOrderStatus(Long orderId, OrderStatus status) {
           // 具体实现
       }
       
       private void sendPaymentNotification(Long userId, Long orderId) {
           // 具体实现
       }
   }
   ```

## 七、模板方法模式精细化规范

### 【强制】模板方法模式适用场景
```
提示词：@codebase 检查以下场景是否适合使用模板方法模式：
1. 多个类有相同的处理流程但某些步骤实现不同
2. 需要控制子类的扩展点
3. 有明确的算法骨架且步骤顺序固定
4. 希望避免代码重复

如果满足3个以上条件，必须使用模板方法模式
```

### 【强制】模板方法实现规范
1. **抽象模板类规范**：
   ```java
   // 【强制】抽象类命名：Abstract + 业务名称 + Template
   public abstract class AbstractDataProcessorTemplate {
       
       // 【强制】模板方法必须为final，不允许子类重写
       public final ProcessResult processData(DataInput input) {
           // 【强制】固定的处理流程
           validateInput(input);                    // 1. 输入校验
           RawData rawData = extractData(input);    // 2. 数据提取（抽象）
           CleanData cleanData = cleanData(rawData); // 3. 数据清洗（抽象）
           ProcessedData processedData = transformData(cleanData); // 4. 数据转换（抽象）
           ProcessResult result = saveData(processedData); // 5. 数据保存（抽象）
           afterProcess(result);                    // 6. 后置处理（钩子方法）
           return result;
       }
       
       // 【强制】通用步骤在父类实现
       private void validateInput(DataInput input) {
           if (input == null || input.getData() == null) {
               throw new ProjectBizException(ErrorCode.INVALID_INPUT, "输入数据不能为空");
           }
       }
       
       // 【强制】抽象方法：子类必须实现的步骤
       protected abstract RawData extractData(DataInput input);
       protected abstract CleanData cleanData(RawData rawData);
       protected abstract ProcessedData transformData(CleanData cleanData);
       protected abstract ProcessResult saveData(ProcessedData processedData);
       
       // 【强制】钩子方法：子类可选择实现
       protected void afterProcess(ProcessResult result) {
           log.info("数据处理完成，处理结果：{}", result.getStatus());
       }
   }
   ```

2. **具体实现类规范**：
   ```java
   @Component
   public class CsvDataProcessor extends AbstractDataProcessorTemplate {
       
       @Override
       protected RawData extractData(DataInput input) {
           // 【强制】必须包含具体实现逻辑
           if (!(input instanceof CsvDataInput)) {
               throw new ProjectBizException(ErrorCode.UNSUPPORTED_INPUT_TYPE, 
                   "CSV处理器只支持CSV输入");
           }
           
           CsvDataInput csvInput = (CsvDataInput) input;
           return csvParser.parse(csvInput.getFilePath());
       }
       
       @Override
       protected CleanData cleanData(RawData rawData) {
           // CSV特定的数据清洗逻辑
           return csvDataCleaner.clean(rawData);
       }
       
       // 其他抽象方法实现...
   }
   ```

## 八、责任链模式精细化规范

### 【强制】责任链模式适用场景
```
提示词：@codebase 检查以下场景是否适合使用责任链模式：
1. 有多个对象可以处理同一请求
2. 处理者的顺序需要动态配置
3. 请求的处理过程需要记录或监控
4. 希望发送者与接收者解耦

如果满足3个以上条件，必须使用责任链模式
```

### 【强制】责任链实现规范
1. **抽象处理者规范**：
   ```java
   // 【强制】处理者基类命名：Abstract + 业务名称 + Handler
   public abstract class AbstractValidationHandler {
       
       protected AbstractValidationHandler nextHandler;
       
       // 【强制】设置下一个处理者
       public void setNextHandler(AbstractValidationHandler nextHandler) {
           this.nextHandler = nextHandler;
       }
       
       // 【强制】模板方法：统一的处理流程
       public final ValidationResult handle(ValidationRequest request) {
           try {
               // 当前处理者处理
               ValidationResult result = doHandle(request);
               
               // 如果处理失败且有下一个处理者，继续处理
               if (!result.isSuccess() && nextHandler != null) {
                   return nextHandler.handle(request);
               }
               
               return result;
               
           } catch (Exception e) {
               log.error("验证处理失败：{}", getHandlerName(), e);
               return ValidationResult.failure(ErrorCode.VALIDATION_ERROR, e.getMessage());
           }
       }
       
       // 【强制】抽象方法：具体处理逻辑
       protected abstract ValidationResult doHandle(ValidationRequest request);
       
       // 【强制】抽象方法：处理者名称（用于日志）
       protected abstract String getHandlerName();
   }
   ```

2. **具体处理者规范**：
   ```java
   @Component
   public class ParameterValidationHandler extends AbstractValidationHandler {
       
       @Override
       protected ValidationResult doHandle(ValidationRequest request) {
           if (request.getParameters() == null || request.getParameters().isEmpty()) {
               return ValidationResult.failure(ErrorCode.MISSING_PARAMETERS, "缺少必要参数");
           }
           
           // 参数格式校验
           for (Map.Entry<String, Object> entry : request.getParameters().entrySet()) {
               if (!isValidParameter(entry.getKey(), entry.getValue())) {
                   return ValidationResult.failure(ErrorCode.INVALID_PARAMETER, 
                       "参数格式错误: " + entry.getKey());
               }
           }
           
           return ValidationResult.success();
       }
       
       @Override
       protected String getHandlerName() {
           return "参数验证处理器";
       }
       
       private boolean isValidParameter(String key, Object value) {
           // 具体参数校验逻辑
           return true;
       }
   }
   ```

3. **责任链管理器规范**：
   ```java
   @Service
   @RequiredArgsConstructor
   public class ValidationChainManager {
       
       private final List<AbstractValidationHandler> handlers;
       
       @PostConstruct
       public void initChain() {
           // 【强制】按顺序构建责任链
           for (int i = 0; i < handlers.size() - 1; i++) {
               handlers.get(i).setNextHandler(handlers.get(i + 1));
           }
       }
       
       public ValidationResult validate(ValidationRequest request) {
           if (handlers.isEmpty()) {
               throw new ProjectBizException(ErrorCode.NO_VALIDATION_HANDLER, "没有可用的验证处理器");
           }
           
           return handlers.get(0).handle(request);
       }
   }
   ```

## 九、单例模式精细化规范

### 【强制】单例模式适用场景
```
提示词：@codebase 检查以下场景是否需要使用单例模式：
1. 全局只能有一个实例的资源（如配置管理器）
2. 创建成本很高的对象（如数据库连接池）
3. 无状态的工具类
4. 系统级的服务组件

注意：Spring环境下优先使用@Component单例管理
```

### 【强制】单例实现规范
1. **枚举单例（推荐）**：
   ```java
   // 【强制】线程安全的单例实现
   public enum ConfigurationManager {
       INSTANCE;
       
       private final Map<String, String> configurations = new ConcurrentHashMap<>();
       
       public void setConfiguration(String key, String value) {
           configurations.put(key, value);
       }
       
       public String getConfiguration(String key) {
           return configurations.get(key);
       }
       
       public String getConfiguration(String key, String defaultValue) {
           return configurations.getOrDefault(key, defaultValue);
       }
   }
   
   // 使用方式
   // ConfigurationManager.INSTANCE.setConfiguration("key", "value");
   ```

2. **Spring管理单例（推荐）**：
   ```java
   @Component
   @Scope("singleton")  // 默认就是单例，可以省略
   public class SystemConfigurationService {
       
       private final Map<String, Object> cache = new ConcurrentHashMap<>();
       
       @PostConstruct
       public void init() {
           loadConfigurations();
       }
       
       private void loadConfigurations() {
           // 加载配置逻辑
       }
   }
   ```

## 十、装饰器模式精细化规范

### 【强制】装饰器模式适用场景
```
提示词：@codebase 检查以下场景是否适合使用装饰器模式：
1. 需要动态给对象添加功能
2. 功能组合需要灵活配置
3. 不适合使用继承扩展功能
4. 需要透明地增强现有对象

优先考虑Spring AOP，装饰器模式用于特殊场景
```

### 【强制】装饰器实现规范
1. **组件接口规范**：
   ```java
   public interface MessageSender {
       void sendMessage(Message message);
   }
   ```

2. **具体组件规范**：
   ```java
   @Component("basicMessageSender")
   public class BasicMessageSender implements MessageSender {
       
       @Override
       public void sendMessage(Message message) {
           // 基础发送逻辑
           log.info("发送消息：{}", message.getContent());
           // 实际发送实现
       }
   }
   ```

3. **装饰器基类规范**：
   ```java
   public abstract class MessageSenderDecorator implements MessageSender {
       
       protected final MessageSender delegate;
       
       public MessageSenderDecorator(MessageSender delegate) {
           this.delegate = Objects.requireNonNull(delegate, "委托对象不能为空");
       }
       
       @Override
       public void sendMessage(Message message) {
           delegate.sendMessage(message);
       }
   }
   ```

4. **具体装饰器规范**：
   ```java
   @Component
   public class EncryptionMessageDecorator extends MessageSenderDecorator {
       
       private final EncryptionService encryptionService;
       
       public EncryptionMessageDecorator(
           @Qualifier("basicMessageSender") MessageSender delegate,
           EncryptionService encryptionService) {
           super(delegate);
           this.encryptionService = encryptionService;
       }
       
       @Override
       public void sendMessage(Message message) {
           // 【强制】前置增强
           Message encryptedMessage = encryptMessage(message);
           
           // 调用委托对象
           super.sendMessage(encryptedMessage);
           
           // 【强制】后置处理（如需要）
           log.info("消息加密发送完成");
       }
       
       private Message encryptMessage(Message message) {
           String encryptedContent = encryptionService.encrypt(message.getContent());
           return message.withContent(encryptedContent);
       }
   }
   ```

## 十一、命令模式精细化规范

### 【强制】命令模式适用场景
```
提示词：@codebase 检查以下场景是否适合使用命令模式：
1. 需要将请求封装为对象（支持撤销、重做）
2. 需要支持事务和批处理
3. 需要记录操作日志
4. 需要支持异步执行

如果满足2个以上条件，推荐使用命令模式
```

### 【强制】命令模式实现规范
1. **命令接口规范**：
   ```java
   public interface Command {
       
       // 【强制】执行命令
       CommandResult execute();
       
       // 【强制】撤销命令（如支持）
       CommandResult undo();
       
       // 【强制】命令标识
       String getCommandId();
       
       // 【强制】命令描述
       String getDescription();
       
       // 【强制】是否支持撤销
       boolean isUndoable();
   }
   ```

2. **具体命令规范**：
   ```java
   public class CreateOrderCommand implements Command {
       
       private final String commandId;
       private final OrderService orderService;
       private final CreateOrderRequest request;
       private Long createdOrderId; // 用于撤销
       
       public CreateOrderCommand(OrderService orderService, CreateOrderRequest request) {
           this.commandId = UUID.randomUUID().toString();
           this.orderService = Objects.requireNonNull(orderService);
           this.request = Objects.requireNonNull(request);
       }
       
       @Override
       public CommandResult execute() {
           try {
               Order order = orderService.createOrder(request);
               this.createdOrderId = order.getId();
               
               return CommandResult.success(commandId, "订单创建成功", order);
               
           } catch (Exception e) {
               log.error("创建订单命令执行失败：{}", commandId, e);
               return CommandResult.failure(commandId, "订单创建失败", e);
           }
       }
       
       @Override
       public CommandResult undo() {
           if (!isUndoable() || createdOrderId == null) {
               return CommandResult.failure(commandId, "命令不支持撤销或未执行");
           }
           
           try {
               orderService.cancelOrder(createdOrderId);
               return CommandResult.success(commandId, "订单创建已撤销");
               
           } catch (Exception e) {
               log.error("撤销创建订单命令失败：{}", commandId, e);
               return CommandResult.failure(commandId, "撤销失败", e);
           }
       }
       
       @Override
       public String getCommandId() {
           return commandId;
       }
       
       @Override
       public String getDescription() {
           return "创建订单：用户ID=" + request.getUserId();
       }
       
       @Override
       public boolean isUndoable() {
           return true;
       }
   }
   ```

3. **命令调用者规范**：
   ```java
   @Service
   public class CommandInvoker {
       
       private final Stack<Command> executedCommands = new Stack<>();
       private final CommandAuditService auditService;
       
       public CommandResult executeCommand(Command command) {
           // 【强制】记录命令执行
           auditService.recordCommandStart(command);
           
           try {
               CommandResult result = command.execute();
               
               if (result.isSuccess() && command.isUndoable()) {
                   executedCommands.push(command);
               }
               
               // 【强制】记录执行结果
               auditService.recordCommandResult(command, result);
               
               return result;
               
           } catch (Exception e) {
               log.error("命令执行异常：{}", command.getCommandId(), e);
               CommandResult errorResult = CommandResult.failure(command.getCommandId(), "执行异常", e);
               auditService.recordCommandResult(command, errorResult);
               return errorResult;
           }
       }
       
       public CommandResult undoLastCommand() {
           if (executedCommands.isEmpty()) {
               return CommandResult.failure("", "没有可撤销的命令");
           }
           
           Command lastCommand = executedCommands.pop();
           return lastCommand.undo();
       }
   }
   ```

## 十二、Cursor智能辅助与规范检查

### 【推荐】设计模式智能选择
```
提示词模板：
@codebase 分析这段代码，确定是否需要应用设计模式：
[粘贴待分析代码]

请按以下标准分析：
1. 代码复杂度评估（圈复杂度、分支数量）
2. 重复代码识别
3. 扩展点分析
4. 推荐的具体设计模式
5. 预期改进效果

只有在明确能带来价值时才推荐引入设计模式。
```

### 【推荐】设计模式实现检查
```
提示词模板：
@codebase 检查这个设计模式实现是否符合规范：
[粘贴设计模式实现代码]

检查标准：
1. 命名规范是否正确
2. 结构是否完整
3. 异常处理是否到位
4. 是否存在过度设计
5. 与现有代码的集成是否合理
```

### 【推荐】设计模式组合使用检查
```
提示词模板：
@codebase 检查多个设计模式的组合使用是否合理：
[粘贴组合使用的代码]

检查内容：
1. 模式间的协作是否清晰
2. 是否存在过度抽象
3. 整体复杂度是否可控
4. 是否有更简单的解决方案
```

---

## 八、规范集成与约束

### 【重要】与其他规范的强制约束
1. **代码质量约束**：
   - 所有设计模式实现必须遵循 [java-code-development-and-quality.mdc](mdc:.cursor/rules/java-code-development-and-quality.mdc) 的方法设计原则
   - 异常处理必须遵循 [java-error-handling-and-operations.mdc](mdc:.cursor/rules/java-error-handling-and-operations.mdc) 规范
   - 事务处理必须符合现有事务管理规范

2. **架构约束**：
   - 设计模式必须适配 [java-project-architecture-and-structure.mdc](mdc:.cursor/rules/java-project-architecture-and-structure.mdc) 的分层架构
   - 包结构必须符合项目现有的组织方式

### 【核心价值】精细化规范的优势
- **🎯 明确指导**：每个模式都有具体的适用条件和实现步骤
- **⚡ 避免混乱**：严格的命名和结构规范防止实现混乱
- **🛡️ 质量保证**：强制的校验和异常处理确保代码质量
- **📚 团队一致**：统一的实现模板保证团队代码风格一致
- **🔍 问题预防**：详细的约束条件避免过度设计和误用