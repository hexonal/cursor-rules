---
description: 
globs: 
alwaysApply: true
---
# .NET WebSocket 客户端开发规范

本规范旨在为 .NET 项目中开发 WebSocket 客户端提供一套统一的指导原则和最佳实践，确保代码的健壮性、可维护性和性能。

---

## 一、引言与目的

### 1.1 目的
- 规范 WebSocket 客户端的实现方式。
- 提升连接的稳定性和可靠性。
- 统一错误处理和日志记录策略。
- 促进代码质量和团队协作效率。

### 1.2 适用范围
本规范主要适用于采用 **.NET 6 及更高版本** 进行 WebSocket 客户端开发的各类项目场景。
规范中推荐的核心库 `System.Net.WebSockets.ClientWebSocket` 的使用方法、部分高级特性（如 `IAsyncDisposable` 接口的直接实现）以及提供的示例代码主要基于 .NET 6 及以上版本。

对于使用较低 .NET 版本（例如 .NET Framework 4.5+ 或 .NET Core 2.1 至 .NET 5）的项目：
- `ClientWebSocket` 的基本功能（如连接、发送、接收文本和二进制消息）仍然可用。
- 但开发者需要注意，本规范中提及的部分API特性、异步模式、依赖注入配置或资源管理最佳实践（如直接在 `ClientWebSocket` 实例上使用 `await using`）可能不完全适用或需要进行适配。
- 此时，应参照对应 .NET 版本的官方文档和社区实践，并结合本规范的核心原则进行 WebSocket 客户端开发。

本规范旨在覆盖广泛的 .NET 应用类型，包括但不限于：
- 桌面应用程序 (WPF, Windows Forms, MAUI)
- Web 应用程序 (ASP.NET Core 后端服务，Blazor WebAssembly 客户端)
- 控制台应用程序和服务
- 移动应用程序 (Xamarin, .NET MAUI)

---

## 二、核心概念

- **WebSocket**: 一种在单个 TCP 连接上进行全双工通信的协议。
- **客户端 (Client)**: 发起 WebSocket 连接的一方。
- **服务端 (Server)**: 接受 WebSocket 连接并与之通信的一方。
- **握手 (Handshake)**: HTTP/HTTPS 升级请求，用于建立 WebSocket 连接。
- **消息 (Message)**: 客户端与服务端之间交换的数据单元，可以是文本或二进制格式。
- **帧 (Frame)**: WebSocket 通信的最小数据单位，消息可以被分割成多个帧。
- **Ping/Pong**: WebSocket 协议内置的保活机制帧。

---

## 三、客户端实现指南

### 3.1 库选择

- **【强制】** 优先使用 .NET 内置的 `System.Net.WebSockets.ClientWebSocket` 类进行 WebSocket 客户端开发。它提供了完整的 WebSocket 功能，并且与 .NET 生态系统紧密集成。
- **【可选】** 对于更高级的场景或需要额外功能的（如自动重连、连接管理抽象、多传输协议支持、Hub概念等），可以考虑使用成熟的第三方库或框架。
    - **SignalR Client (`Microsoft.AspNetCore.SignalR.Client`)**: 如果服务端使用 ASP.NET Core SignalR，强烈推荐使用其官方客户端。它封装了大量复杂性，包括连接管理、重连、多种传输协议协商、消息序列化等。
    - 其他第三方库 (例如旧的 `WebSocket4Net` 主要用于 .NET Framework，或现代的一些社区库)：需仔细评估其维护状态、社区支持、功能集和项目兼容性。
- **【推荐】** 无论选择何种库，都应将其核心交互逻辑封装在自定义的管理器或服务类中，以隔离依赖和统一控制。

### 3.2 连接管理

#### 3.2.1 建立连接
- **【强制】** 使用 `ClientWebSocket.ConnectAsync(Uri, CancellationToken)` 方法异步建立连接。
- **【强制】** 必须处理连接过程中可能发生的异常，如 `WebSocketException`, `HttpRequestException`, `TaskCanceledException` (超时或手动取消)。具体异常处理应遵循 `@dotnet-error-handling-and-operations.mdc` 规范，考虑将底层异常包装为 `BizException` 或特定的应用异常。
- **【推荐】** 配置合理的连接超时时间。可以通过 `CancellationTokenSource` 实现。
- **【推荐】** WebSocket 服务端 URI 地址应通过配置系统加载（例如 `appsettings.json` 和 `IOptions<T>` 模式），具体参考 `@dotnet-project-architecture-and-structure.mdc` 和 `@dotnet-code-development-and-quality.mdc` 中的配置管理规范。
  ```csharp
  using System;
  using System.Net.WebSockets;
  using System.Threading;
  using System.Threading.Tasks;
  using Microsoft.Extensions.Logging; // 引入 ILogger
  using Microsoft.Extensions.Options;  // 引入 IOptions (用于配置)

  public class WebSocketOptions
  {
      public string ServerUri { get; set; }
      public int ConnectTimeoutSeconds { get; set; } = 10;
      // 可以添加其他配置，如请求头、子协议等
  }

  public class WebSocketClientManager : IAsyncDisposable // 推荐实现 IAsyncDisposable
  {
      private ClientWebSocket _clientWebSocket;
      private readonly Uri _serverUri;
      private readonly ILogger<WebSocketClientManager> _logger;
      private readonly WebSocketOptions _options;
      private CancellationTokenSource _internalCts; // 用于管理内部操作的取消

      public WebSocketClientManager(IOptions<WebSocketOptions> options, ILogger<WebSocketClientManager> logger)
      {
          _options = options.Value ?? throw new ArgumentNullException(nameof(options));
          _logger = logger ?? throw new ArgumentNullException(nameof(logger));
          
          if (string.IsNullOrWhiteSpace(_options.ServerUri) || !Uri.TryCreate(_options.ServerUri, UriKind.Absolute, out _serverUri))
          {
              throw new ArgumentException("WebSocket Server URI is invalid.", nameof(options));
          }
          // _clientWebSocket 实例在 ConnectAsync 中创建或在需要时重新创建
      }

      public async Task ConnectAsync(CancellationToken externalCancellationToken)
      {
          if (_clientWebSocket?.State == WebSocketState.Open)
          {
              _logger.LogInformation("WebSocket is already open to {ServerUri}.", _serverUri);
              return;
          }

          _clientWebSocket?.Dispose(); // 清理旧实例（如果有）
          _clientWebSocket = new ClientWebSocket();
          
          // 【认证】设置认证相关的HTTP头部。Token应通过安全方式获取，并考虑其生命周期和刷新机制。
          // 例如: 
          // string accessToken = await GetValidAccessTokenAsync(); // 假设有获取/刷新Token的逻辑
          // if (!string.IsNullOrEmpty(accessToken))
          // {
          //     _clientWebSocket.Options.SetRequestHeader("Authorization", $"Bearer {accessToken}");
          // }
          // else
          // {
          //     _logger.LogWarning("Access token is not available. Connecting without Authorization header.");
          //     // 可能需要根据业务决定是否允许在无Token情况下连接
          // }
          // _clientWebSocket.Options.AddSubProtocol("your-subprotocol");

          _internalCts = CancellationTokenSource.CreateLinkedTokenSource(externalCancellationToken);
          var connectTimeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(_options.ConnectTimeoutSeconds));
          var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(_internalCts.Token, connectTimeoutCts.Token);

          try
          {
              _logger.LogInformation("Attempting to connect to WebSocket server: {ServerUri}", _serverUri);
              await _clientWebSocket.ConnectAsync(_serverUri, linkedCts.Token);
              _logger.LogInformation("WebSocket connected successfully to: {ServerUri}", _serverUri);
              
              // 连接成功后，启动消息接收循环
              // _ = StartReceiveLoopAsync(_internalCts.Token); // 使用 _internalCts
          }
          catch (WebSocketException ex)
          {
              _logger.LogError(ex, "WebSocket connection error to {ServerUri}. ErrorCode: {WebSocketErrorCode}, NativeErrorCode: {NativeErrorCode}", _serverUri, ex.WebSocketErrorCode, ex.NativeErrorCode);
              // 根据 @dotnet-error-handling-and-operations.mdc 转换为 BizException
              // throw new BizException(AppErrorCodes.WebSocketConnectFailed, $"连接WebSocket服务器 {_serverUri} 失败。", ex);
              throw; // 或者直接向上抛出，由全局异常处理器处理
          }
          catch (HttpRequestException ex)
          {
              _logger.LogError(ex, "WebSocket HTTP connection error to {ServerUri}", _serverUri);
              // throw new BizException(AppErrorCodes.WebSocketHttpConnectFailed, $"WebSocket HTTP 连接到 {_serverUri} 失败。", ex);
              throw;
          }
          catch (TaskCanceledException) when (connectTimeoutCts.IsCancellationRequested)
          {
              _logger.LogWarning("WebSocket connection attempt to {ServerUri} timed out after {Timeout} seconds.", _serverUri, _options.ConnectTimeoutSeconds);
              // throw new BizException(AppErrorCodes.WebSocketConnectTimeout, $"连接WebSocket服务器 {_serverUri} 超时。");
              throw;
          }
          catch (TaskCanceledException) when (externalCancellationToken.IsCancellationRequested)
          {
              _logger.LogInformation("WebSocket connection attempt to {ServerUri} was canceled by the user.", _serverUri);
              throw; // 重新抛出以便调用者知道是外部取消
          }
          catch (Exception ex)
          {
              _logger.LogError(ex, "An unexpected error occurred during WebSocket connection to {ServerUri}", _serverUri);
              // throw new BizException(AppErrorCodes.WebSocketUnexpectedError, $"连接WebSocket服务器 {_serverUri} 时发生未知错误。", ex);
              throw;
          }
          finally
          {
              connectTimeoutCts.Dispose();
              linkedCts.Dispose();
          }
      }
  }
  ```
- **【推荐】** 在连接时可以设置自定义的 HTTP头部 (例如认证Token)，通过 `_clientWebSocket.Options.SetRequestHeader(string, string)`。如果Token会过期，需要考虑Token刷新机制。

#### 3.2.2 维持连接与状态监控
- **【强制】** 客户端必须能够感知连接状态 (`_clientWebSocket.State`)，例如 `Open`, `Closed`, `Aborted`。
- **【推荐】** 实现心跳机制 (见 3.6 节) 以维持连接活跃并检测死连接。

#### 3.2.3 关闭连接
- **【强制】** 正常关闭连接时，应首先调用 `_clientWebSocket.CloseAsync(WebSocketCloseStatus, string, CancellationToken)` 发送关闭帧给服务端。
- **【强制】** 服务端发起关闭时，客户端应正确响应关闭握手，调用 `_clientWebSocket.CloseAsync`。
- **【强制】** 优雅关闭失败或连接异常断开时，也应确保 `ClientWebSocket` 实例被正确 `Dispose()` 以释放资源。
- **【推荐】** 定义明确的关闭状态码 (`WebSocketCloseStatus`) 和描述信息。
  ```csharp
  public async Task DisconnectAsync(CancellationToken cancellationToken)
  {
      if (_clientWebSocket == null)
      {
          _logger.LogInformation("WebSocket client is not initialized, no action taken for disconnect.");
          return;
      }

      _internalCts?.Cancel(); // 取消所有内部操作，如接收循环

      var currentState = _clientWebSocket.State;
      _logger.LogInformation("Attempting to disconnect WebSocket. Current state: {State}", currentState);

      if (currentState == WebSocketState.Open || currentState == WebSocketState.CloseReceived)
      {
          try
          {
              var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5)); // 5秒关闭超时
              var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, cts.Token);
              
              await _clientWebSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Client initiated disconnect", linkedCts.Token);
              _logger.LogInformation("WebSocket connection closed normally.");
          }
          catch (WebSocketException ex)
          {
              _logger.LogWarning(ex, "Error during WebSocket graceful close. State: {State}", _clientWebSocket.State);
              // 即使关闭出错，仍继续尝试中止和清理
              _clientWebSocket.Abort(); // 强制中止
          }
          catch (OperationCanceledException ex) when (cancellationToken.IsCancellationRequested)
          {
              _logger.LogInformation("WebSocket close operation was canceled by the caller.");
              _clientWebSocket.Abort();
          }
          catch (OperationCanceledException ex) // 超时
          {
              _logger.LogWarning(ex, "WebSocket graceful close timed out. Aborting.");
              _clientWebSocket.Abort();
          }
          catch (Exception ex)
          {
              _logger.LogError(ex, "Unexpected error during WebSocket graceful close. Aborting.");
              _clientWebSocket.Abort();
          }
      }
      else if (currentState != WebSocketState.Closed && currentState != WebSocketState.Aborted && currentState != WebSocketState.None) // None通常是初始状态
      {
          _logger.LogWarning("WebSocket is in an unexpected state ({State}) for graceful close, aborting.", currentState);
          _clientWebSocket.Abort();
      }
      
      // Dispose总是在finally或外部确保执行
      // DisposeClient(); // 见下方 IAsyncDisposable 实现
  }

  // 推荐将 DisposeClient 放到 IAsyncDisposable.DisposeAsync 中
  public async ValueTask DisposeAsync()
  {
      _logger.LogInformation("Disposing WebSocketClientManager.");
      _internalCts?.Cancel();
      _internalCts?.Dispose();

      if (_clientWebSocket != null)
      {
          if (_clientWebSocket.State == WebSocketState.Open || _clientWebSocket.State == WebSocketState.CloseReceived)
          {
              try
              {
                  // 尝试最后一次优雅关闭，但不阻塞太久
                  using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(2));
                  await _clientWebSocket.CloseOutputAsync(WebSocketCloseStatus.NormalClosure, "Disposing client", cts.Token);
              }
              catch (Exception ex)
              {
                  _logger.LogWarning(ex, "Exception during DisposeAsync close output. State: {State}", _clientWebSocket.State);
                  // 忽略这里的异常，因为我们无论如何都要Dispose
              }
          }
          // 无论状态如何，都要 Dispose
          _clientWebSocket.Dispose();
          _clientWebSocket = null;
          _logger.LogInformation("ClientWebSocket disposed.");
      }
  }
  ```

### 3.3 消息发送

- **【强制】** 使用 `_clientWebSocket.SendAsync(ArraySegment<byte>, WebSocketMessageType, bool, CancellationToken)` 异步发送消息。
- **【强制】** 根据消息内容选择正确的 `WebSocketMessageType` (`Text` 或 `Binary`)。
- **【推荐】** 对于大消息，应考虑分片发送。`SendAsync` 的 `endOfMessage` 参数设置为 `false` 直到最后一个分片。
    - 需要注意的是，`ClientWebSocket` 对发送大消息的底层分片处理是自动的（通常在内部按WebSocket协议帧大小分片），开发者通常只需要关注逻辑上的消息边界 (`endOfMessage` 设为 `true` 表示一个完整应用层消息的结束)。但如果应用层需要显式控制分片，则需要手动管理。
- **【强制】** 序列化和反序列化逻辑 (例如 JSON `System.Text.Json`, Protobuf `protobuf-net`) 应与消息发送/接收逻辑分离，可以封装在单独的服务或辅助类中。
- **【推荐】** 为发送操作设置合理的超时和 `CancellationToken`。
  ```csharp
  using System.Text;
  using System.Text.Json; // 用于 System.Text.Json 示例

  public async Task SendMessageAsync<T>(T messagePayload, CancellationToken cancellationToken)
  {
      if (_clientWebSocket?.State != WebSocketState.Open)
      {
          _logger.LogWarning("Cannot send message, WebSocket is not open. Current state: {State}", _clientWebSocket?.State);
          // throw new InvalidOperationException("WebSocket is not open."); // 或其他处理方式
          return;
      }

      try
      {
          // 假设使用 System.Text.Json 进行序列化
          var serializedMessage = JsonSerializer.Serialize(messagePayload); 
          var messageBuffer = Encoding.UTF8.GetBytes(serializedMessage);
          var segment = new ArraySegment<byte>(messageBuffer);

          await _clientWebSocket.SendAsync(segment, WebSocketMessageType.Text, true, cancellationToken);
          _logger.LogDebug("Message sent: {MessagePayload}", serializedMessage); // 注意日志级别和敏感信息
      }
      catch (WebSocketException ex)
      {
          _logger.LogError(ex, "Error sending message. WebSocket state: {State}", _clientWebSocket.State);
          // 处理发送错误，可能需要关闭连接并尝试重连
          // await HandleDisconnectionAndAttemptReconnect(cancellationToken);
          throw;
      }
      catch (JsonException ex)
      {
          _logger.LogError(ex, "Error serializing message payload: {PayloadType}", typeof(T).FullName);
          // throw new BizException(AppErrorCodes.SerializationFailed, "消息序列化失败。", ex);
          throw;
      }
      catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
      {
          _logger.LogInformation("Send operation was canceled by the caller.");
          throw;
      }
      catch (Exception ex)
      {
          _logger.LogError(ex, "An unexpected error occurred during send.");
          // throw new BizException(AppErrorCodes.WebSocketSendUnexpectedError, "发送消息时发生未知错误。", ex);
          throw;
      }
  }
  ```

### 3.4 消息接收

- **【强制】** 在连接成功后，必须启动一个独立的、持续的循环来接收消息，使用 `_clientWebSocket.ReceiveAsync(ArraySegment<byte>, CancellationToken)`。该循环应在单独的任务中运行，不阻塞 `ConnectAsync` 的调用者。
- **【强制】** `ReceiveAsync` 的循环必须能正确处理不同类型的消息结果：
    - `WebSocketMessageType.Text`: 文本消息。
    - `WebSocketMessageType.Binary`: 二进制消息。
    - `WebSocketMessageType.Close`: 服务端发起的关闭帧。客户端应响应并关闭连接。
- **【强制】** 必须处理接收过程中可能发生的 `WebSocketException` 和 `OperationCanceledException`。异常处理应遵循 `@dotnet-error-handling-and-operations.mdc`。
- **【推荐】** 使用合理的缓冲区大小 (例如 4KB 或 8KB)。如果消息可能超过缓冲区大小，需要循环调用 `ReceiveAsync` 直到 `WebSocketReceiveResult.EndOfMessage` 为 `true`，并将分片数据累积到 `MemoryStream`。
  ```csharp
  public async Task StartReceiveLoopAsync(CancellationToken cancellationToken) // 此方法通常在ConnectAsync成功后 fire-and-forget 启动
  {
      // 注意: 这个方法的 CancellationToken 应该是 _internalCts.Token, 独立于 ConnectAsync 的 token
      var buffer = new ArraySegment<byte>(new byte[8192]); // 8KB buffer
      _logger.LogInformation("Starting WebSocket receive loop for {ServerUri}", _serverUri);

      try
      {
          while (_clientWebSocket.State == WebSocketState.Open && !cancellationToken.IsCancellationRequested)
          {
              WebSocketReceiveResult result;
              using (var ms = new MemoryStream())
              {
                  do
                  {
                      // 等待接收消息，如果cancellationToken被触发，则会抛出OperationCanceledException
                      result = await _clientWebSocket.ReceiveAsync(buffer, cancellationToken);
                      
                      if (result.MessageType == WebSocketMessageType.Close)
                      {
                          _logger.LogInformation("Close message received from server: {CloseStatus} - {StatusDescription}", result.CloseStatus, result.CloseStatusDescription);
                          if (_clientWebSocket.State == WebSocketState.CloseReceived) // 确保是服务器发起的关闭
                          {
                              // 响应关闭握手
                              await _clientWebSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Client acknowledging close", CancellationToken.None); // 使用新的token
                              _logger.LogInformation("Client acknowledged server close. WebSocket closed.");
                          }
                          // OnDisconnected?.Invoke(this, new DisconnectedEventArgs(result.CloseStatus, result.CloseStatusDescription));
                          return; // 退出接收循环
                      }
                      ms.Write(buffer.Array, buffer.Offset, result.Count);
                  }
                  while (!result.EndOfMessage && !cancellationToken.IsCancellationRequested);

                  if (cancellationToken.IsCancellationRequested)
                  {
                     _logger.LogInformation("Receive operation canceled during message assembly.");
                     break; // 退出while循环
                  }

                  ms.Seek(0, SeekOrigin.Begin);

                  if (result.MessageType == WebSocketMessageType.Text)
                  {
                      using (var reader = new StreamReader(ms, Encoding.UTF8))
                      {
                          var message = await reader.ReadToEndAsync();
                          _logger.LogDebug("Received Text Message: {Message}", message); // 注意日志级别和敏感信息
                          // ProcessTextMessage(message); // 将消息分发给处理逻辑
                          // OnMessageReceived?.Invoke(this, new MessageReceivedEventArgs(message, WebSocketMessageType.Text));
                      }
                  }
                  else if (result.MessageType == WebSocketMessageType.Binary)
                  {
                      var binaryData = ms.ToArray();
                      _logger.LogDebug("Received Binary Message: {Length} bytes", binaryData.Length);
                      // ProcessBinaryMessage(binaryData);
                      // OnMessageReceived?.Invoke(this, new MessageReceivedEventArgs(binaryData, WebSocketMessageType.Binary));
                  }
              } // MemoryStream disposed here
          }
      }
      catch (WebSocketException ex) when (ex.WebSocketErrorCode == WebSocketError.ConnectionClosedPrematurely || 
                                           ex.WebSocketErrorCode == WebSocketError.InvalidState && !cancellationToken.IsCancellationRequested)
      {
          // 连接意外关闭或处于无效状态（且非主动取消）
          _logger.LogWarning(ex, "WebSocket receive loop ended due to connection issue. State: {State}, ErrorCode: {ErrorCode}", _clientWebSocket.State, ex.WebSocketErrorCode);
          // HandleDisconnectionAndAttemptReconnect(cancellationToken); // 触发重连逻辑
      }
      catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
      {
          _logger.LogInformation("WebSocket receive loop was canceled externally.");
          // 通常是 DisconnectAsync 或 DisposeAsync 触发的取消
      }
      catch (Exception ex)
      {
          _logger.LogError(ex, "An unexpected error occurred in WebSocket receive loop. State: {State}", _clientWebSocket.State);
          // HandleDisconnectionAndAttemptReconnect(cancellationToken); // 触发重连逻辑
      }
      finally
      {
          _logger.LogInformation("Exiting WebSocket receive loop for {ServerUri}. Final state: {State}", _serverUri, _clientWebSocket?.State);
          // 如果循环异常退出且连接仍未关闭 (例如, cancellationToken未触发但发生其他错误)
          // 则应确保连接状态得到更新，并可能触发重连或清理
          if (_clientWebSocket?.State != WebSocketState.Closed && _clientWebSocket?.State != WebSocketState.Aborted)
          {
              // 可能需要调用 DisconnectAsync 或 Abort 来确保清理
              // 例如: await HandleDisconnectionAndAttemptReconnect(CancellationToken.None); // 用一个独立的token尝试重连
          }
      }
  }
  ```
- **【推荐】** 将消息处理逻辑（`ProcessTextMessage`, `ProcessBinaryMessage` 或通过事件/回调分发）与接收循环本身分离，以保持接收循环的响应性。可以使用 `System.Threading.Channels.Channel<T>` 或事件委托将接收到的消息异步分发给处理模块。

### 3.5 重连策略

- **【强制】** 必须实现自动重连机制以应对网络抖动或服务端重启。
- **【推荐】** 使用指数退避 (Exponential Backoff) 算法增加重连尝试的间隔时间，避免频繁无效的连接尝试。具体参数（如初始延迟、最大延迟、退避因子）应可配置。
- **【推荐】** 为退避算法引入抖动 (Jitter)，以防止多个客户端在同一时间集中尝试重连。
- **【推荐】** 设置最大重连尝试次数或总重连时间上限，达到上限后应停止尝试并通知应用层面（例如通过事件）。
- **【推荐】** 在重连成功后，可能需要重新订阅或同步状态。触发一个 `Reconnected` 事件通知应用层。
- **【注意】** 如果断开连接的原因是认证失败 (e.g., Token过期)，在尝试重连之前，应首先尝试刷新认证凭据 (参考 3.7.1 节)。
  ```csharp
  // 简化的重连逻辑示例
  private int _reconnectAttempts = 0;
  private readonly int _maxReconnectAttempts = 5; // 应可配置
  private readonly TimeSpan _initialReconnectDelay = TimeSpan.FromSeconds(1); // 应可配置
  private readonly TimeSpan _maxReconnectDelay = TimeSpan.FromSeconds(30); // 应可配置

  private async Task HandleDisconnectionAndAttemptReconnect(CancellationToken cancellationToken) // 通常在接收循环的catch块中调用
  {
      // 首先确保当前实例被正确关闭和清理
      if (_clientWebSocket != null &&_clientWebSocket.State != WebSocketState.Closed && _clientWebSocket.State != WebSocketState.Aborted)
      {
        _logger.LogInformation("Connection lost or in error state. Current state: {State}. Initiating disconnect before reconnect attempt.", _clientWebSocket.State);
        // 使用独立的CancellationToken进行关闭，避免影响重连的主CancellationToken
        await DisconnectAsync(CancellationToken.None); 
      }
      // DisposeAsync会处理_clientWebSocket的Dispose和null赋值
      // await DisposeAsync(); // 或者确保在外部调用
      // _clientWebSocket = new ClientWebSocket(); // ConnectAsync 会创建新实例

      // 避免重入重连逻辑
      if (_reconnectAttempts >= _maxReconnectAttempts) {
          _logger.LogWarning("Already reached max reconnect attempts or reconnect is in progress elsewhere.");
          // OnConnectionFailedPermanently?.Invoke(this, EventArgs.Empty);
          return;
      }
      
      // 【认证相关】如果断连可能是因为认证问题，在这里尝试刷新Token
      // bool tokenRefreshed = await TryRefreshTokenIfNeededAsync();
      // if (!tokenRefreshed && IsAuthError(lastDisconnectReason)) {
      //     _logger.LogError("Authentication token could not be refreshed. Aborting reconnect.");
      //     OnConnectionFailedPermanently?.Invoke(this, EventArgs.Empty);
      //     return;
      // }


      while (_reconnectAttempts < _maxReconnectAttempts && !cancellationToken.IsCancellationRequested)
      {
          _reconnectAttempts++;
          try
          {
              double delaySeconds = Math.Min(_initialReconnectDelay.TotalSeconds * Math.Pow(2, _reconnectAttempts - 1), _maxReconnectDelay.TotalSeconds);
              Random jitter = new Random(); // 为避免多客户端同步，此Random实例应考虑作用域或种子
              delaySeconds += jitter.NextDouble() * delaySeconds * 0.2; // +/- 20% jitter
              
              _logger.LogInformation("Attempting to reconnect in {DelaySeconds:F2} seconds... (Attempt {CurrentAttempt}/{MaxAttempts}) to {ServerUri}", 
                                   delaySeconds, _reconnectAttempts, _maxReconnectAttempts, _serverUri);
              await Task.Delay(TimeSpan.FromSeconds(delaySeconds), cancellationToken);

              _logger.LogInformation("Reconnecting to {ServerUri}...", _serverUri);
              // 假设ConnectAsync会创建新的_clientWebSocket实例
              await ConnectAsync(cancellationToken); // 尝试连接

              if (_clientWebSocket.State == WebSocketState.Open)
              {
                  _logger.LogInformation("Reconnected successfully to {ServerUri}.", _serverUri);
                  _reconnectAttempts = 0; // 重置尝试次数
                  _ = StartReceiveLoopAsync(_internalCts.Token); // 重新开始接收消息 (使用内部的CTS)
                  // OnReconnected?.Invoke(this, EventArgs.Empty); // 触发重连成功事件
                  return; // 成功重连并启动接收后退出
              }
              else
              {
                  _logger.LogWarning("Reconnect attempt {CurrentAttempt} to {ServerUri} failed. Current state: {State}", _reconnectAttempts, _serverUri, _clientWebSocket.State);
              }
          }
          catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
          {
              _logger.LogInformation("Reconnect attempt to {ServerUri} canceled by external token.", _serverUri);
              return; // 外部取消，停止重连
          }
          catch (Exception ex)
          {
              // ConnectAsync 内部应已记录具体连接错误
              _logger.LogWarning(ex, "Reconnect attempt {CurrentAttempt} to {ServerUri} resulted in exception.", _reconnectAttempts, _serverUri);
              // 继续下一次尝试前，确保旧的连接（如果ConnectAsync中途失败未完全清理）被处理
              if (_clientWebSocket != null && _clientWebSocket.State != WebSocketState.Closed && _clientWebSocket.State != WebSocketState.Aborted) {
                  _clientWebSocket.Abort(); // 强制中止，准备下一次创建新实例
              }
          }
      }

      if (!cancellationToken.IsCancellationRequested && _reconnectAttempts >= _maxReconnectAttempts)
      {
          _logger.LogError("Maximum reconnect attempts ({MaxAttempts}) reached for {ServerUri}. Giving up.", _maxReconnectAttempts, _serverUri);
          // OnConnectionFailedPermanently?.Invoke(this, EventArgs.Empty); // 触发永久连接失败事件
      }
  }
  ```

### 3.6 心跳/保活机制

- **【推荐】** 客户端应定期向服务端发送 Ping 帧或应用层心跳消息，以确认连接是否仍然有效，并帮助NAT/防火墙保持连接打开。
- **【推荐】** 服务端通常会响应 Pong 帧或应用层心跳回执。客户端应监控这些响应。
- **【推荐】** 如果在指定时间内未收到服务端的 Pong 或心跳回执，客户端应认为连接已死，并尝试关闭和重连。
- `ClientWebSocket` 本身不直接提供发送 Ping 帧的 API。心跳通常在应用层面实现：
    - 启动一个定时器 (`System.Threading.Timer` 或 `Task.Delay` 循环)。
    - 定期发送一个特定格式的文本或二进制消息作为心跳包 (例如，一个包含 `{"type": "ping"}` 的JSON消息)。
    - 服务端收到该心跳包后，应回复一个对应的 "pong" 消息。
    - 客户端记录上次收到服务端消息（包括pong或任何业务消息）的时间戳。如果长时间未收到任何消息，则认为连接超时。
- **【注意】** .NET 的 `ClientWebSocket` 会自动响应服务端发送的协议级 Ping 帧并自动回复 Pong 帧，这部分由底层处理，无需用户代码干预。应用层心跳主要用于：
    - 检测应用级别的存活状态 (服务端应用是否仍在正常处理逻辑)。
    - 服务端主动检测客户端是否存活。
    - 在某些网络环境下，应用层消息可能比协议级Ping/Pong更容易通过防火墙。
- 心跳间隔和超时时间应可配置。

### 3.7 安全性与认证授权 (Security and Authentication/Authorization)

- **【强制】** 优先使用安全的 WebSocket 连接 (`wss://`)，它基于 TLS/SSL 加密通信，保护传输过程中的数据，包括认证凭据。

#### 3.7.1 认证 (Authentication - 我是谁)

客户端通常需要向WebSocket服务器证明其身份。常见的认证方式包括：

1.  **基于Token的认证 (推荐)**:
    *   **获取Token**: 客户端通常通过一个独立的、安全的HTTP API（例如OAuth2/OIDC流程或自定义登录接口）获取访问令牌 (Access Token)，有时还会有刷新令牌 (Refresh Token)。
    *   **传递Token**: 在调用 `_clientWebSocket.ConnectAsync()` **之前**，将访问令牌设置在HTTP升级请求的头部。
        ```csharp
        // string accessToken = await _authenticationService.GetAccessTokenAsync(); // 示例方法
        // if (!string.IsNullOrEmpty(accessToken))
        // {
        //    _clientWebSocket.Options.SetRequestHeader("Authorization", $"Bearer {accessToken}");
        // }
        ```
    *   **Token生命周期管理**:
        *   **过期处理**: 访问令牌通常具有较短的有效期。客户端必须能够处理Token过期的情况。
            *   **服务端通知**: 服务器可能会在Token无效时拒绝WebSocket连接请求，或在连接后因Token失效而关闭连接（可能使用特定的关闭状态码或错误消息）。
            *   **客户端响应**: 收到此类通知后，客户端应：
                1.  尝试使用刷新令牌（如果可用）获取新的访问令牌。
                2.  如果刷新成功，使用新令牌重新尝试建立WebSocket连接。
                3.  如果刷新失败或无刷新令牌，应引导用户重新认证（例如返回登录界面）。
        *   **主动刷新**: 客户端也可以在访问令牌即将过期前主动刷新它，以尽量避免因Token过期导致的连接中断。
    *   **【注意】** Token刷新逻辑不应阻塞WebSocket的正常操作，可能需要在后台任务中进行。

2.  **基于Cookie的认证**:
    *   如果WebSocket连接是从浏览器环境（或可以共享浏览器Cookie容器的.NET客户端环境）发起的，并且Web应用本身使用基于Cookie的会话管理，那么WebSocket的HTTP升级请求可能会自动携带这些认证Cookie。
    *   可以通过 `_clientWebSocket.Options.UseCookies = true` 和 `_clientWebSocket.Options.Cookies = yourCookieContainer;` 来管理和发送Cookie。
    *   这种方式对于非浏览器或需要独立管理认证状态的.NET客户端可能不太直接或不适用。

3.  **应用层认证**:
    *   在WebSocket连接成功建立（`State == Open`）之后，客户端和服务端可以通过交换特定的认证消息（应用协议的一部分）来完成认证过程。
    *   这种方式更为灵活，但需要在应用层面设计和实现完整的认证握手逻辑。

#### 3.7.2 授权 (Authorization - 我能做什么)

-   **【核心原则】授权决策由服务端负责。** 客户端在通过认证后，服务端会根据其身份和关联的权限来决定允许其执行哪些操作（如发送特定类型的消息、订阅某些频道、访问某些数据等）。
-   **客户端职责**:
    *   客户端不应假定自己拥有某些权限。
    *   客户端应准备好处理因权限不足导致的操作失败。服务端在拒绝操作时，应通过WebSocket消息（例如，包含特定错误码的JSON响应）或关闭连接（使用自定义的关闭状态码和描述）来通知客户端。
    *   客户端收到权限错误通知后，应：
        1.  记录相应的错误日志（遵循 `@dotnet-error-handling-and-operations.mdc`）。
        2.  向用户显示友好的提示信息。
        3.  避免重试无权限的操作。
-   **错误处理**: 客户端在处理来自服务端的消息时，需要检查可能存在的表示授权失败的错误码或消息结构，并将其转换为合适的客户端异常 (例如 `BizException` 携带 `@dotnet-error-handling-and-operations.mdc` 中定义的 `USER_ACCESS_DENIED` 或类似错误码)。

#### 3.7.3 其他安全考量
-   **【推荐】** 确保服务端正确配置了 TLS/SSL 证书。客户端可以配置证书验证回调（`ClientWebSocket.Options.RemoteCertificateValidationCallback`），但这通常用于自签名证书等特殊开发/测试场景，生产环境应使用受信任 CA 颁发的证书，并依赖操作系统的证书信任链。
-   **【注意】** 不要通过 WebSocket 明文传输极为敏感的信息，即使是 `wss://` 内部（防范中间人攻击后的流量解密风险，或服务端日志记录风险）。始终考虑数据本身的敏感性，并采取适当的应用层加密或脱敏措施（如果必要）。

### 3.8 错误处理和日志记录

- **【强制】** 对所有 WebSocket 操作（连接、发送、接收、关闭）进行全面的 `try-catch` 块包裹。
- **【强制】** **必须遵循 `@dotnet-error-handling-and-operations.mdc` 中定义的错误码、异常类型 (`BizException` 或其子类) 和日志记录规范。**
- **【强制】** 日志应使用 `Microsoft.Extensions.Logging.ILogger` 接口，采用结构化日志记录。
- **【强制】** 日志应包含时间戳、日志级别、TraceID (如果可用)、错误类型、错误消息、堆栈跟踪（针对异常）以及相关的上下文信息（如服务端地址、当前连接状态、操作类型）。
- **【推荐】** 将底层的 `WebSocketException` 或其他网络相关异常，根据场景包装为标准的业务异常 (`BizException`) 或特定的应用层通信异常 (例如，自定义一个 `WebSocketServiceException : BizException`)，并赋予规范中定义的错误码。
- **【推荐】** 区分可恢复错误（如临时网络问题导致重连）和不可恢复错误（如认证失败、服务端返回的协议错误）。

### 3.9 资源管理

- **【强制】** `ClientWebSocket` 实现了 `IDisposable` 接口。必须在使用完毕后（例如连接关闭、对象销毁时）调用其 `Dispose()` 方法或使用 `using` 语句块，以确保释放底层资源。
- **【推荐】** 如果将 `ClientWebSocket` 封装在管理器类中，该管理器类应实现 `IAsyncDisposable` (优先) 或 `IDisposable`，并在其 `DisposeAsync()` 或 `Dispose()` 方法中正确处理 `ClientWebSocket` 的关闭与释放。
  ```csharp
  // 使用 using 语句确保 Dispose (适用于临时使用的场景)
  public async Task ConnectAndProcessOnceAsync(Uri serverUri, ILogger logger, CancellationToken cancellationToken)
  {
      // IOptions<WebSocketOptions> options = ...; // 从DI获取配置
      // var manager = new WebSocketClientManager(options, logger);
      // await using (manager) // 利用 IAsyncDisposable
      // {
      //    await manager.ConnectAsync(cancellationToken);
      //    // ... 发送和接收逻辑 ...
      //    await manager.DisconnectAsync(cancellationToken);
      // }

      // 或者直接使用 ClientWebSocket
      await using (var client = new ClientWebSocket()) // ClientWebSocket 实现了 IAsyncDisposable from .NET 6
      {
          // 设置选项
          // client.Options.SetRequestHeader(...);
          logger.LogInformation("Attempting one-time connection to {ServerUri}", serverUri);
          try
          {
              await client.ConnectAsync(serverUri, cancellationToken);
              logger.LogInformation("One-time connection successful to {ServerUri}", serverUri);
              // ... 发送和接收逻辑 ...
          }
          catch (Exception ex)
          {
              logger.LogError(ex, "One-time WebSocket operation failed for {ServerUri}", serverUri);
              // 根据 @dotnet-error-handling-and-operations.mdc 处理异常
          }
          finally
          {
              if (client.State == WebSocketState.Open || client.State == WebSocketState.CloseReceived)
              {
                  logger.LogInformation("Closing one-time WebSocket connection from {ServerUri}. State: {State}", serverUri, client.State);
                  // Use a new CancellationToken for close if original is already cancelled.
                  var closeCts = new CancellationTokenSource(TimeSpan.FromSeconds(5));
                  await client.CloseAsync(WebSocketCloseStatus.NormalClosure, "Client completing one-time operation", closeCts.Token);
              }
              else
              {
                  logger.LogWarning("One-time WebSocket connection for {ServerUri} was not open for graceful close. State: {State}", serverUri, client.State);
              }
          }
      } // client.DisposeAsync() or client.Dispose() 会在此处通过 await using 自动调用
  }
  ```

### 3.10 测试 WebSocket 客户端

- **【推荐】** 编写单元测试和集成测试来验证 WebSocket 客户端的逻辑。
- **【推荐】** 对于单元测试，可以模拟 `ClientWebSocket` 的行为或其依赖的接口。
- **【推荐】** 对于集成测试，可以搭建一个简单的 WebSocket Echo Server 或使用专门的测试服务器。

---

## 四、性能考量

- **【推荐】** 避免在消息处理回调或事件处理器中执行长时间阻塞操作，这会阻塞接收循环或消息分发。将耗时操作派发到其他线程或使用异步任务 (`Task.Run` 或异步消息队列如 `Channel<T>`)。
- **【推荐】** 合理设置接收缓冲区大小 (`new byte[size]`)，避免频繁的小块内存分配，也要避免过大的缓冲区浪费内存。通常4KB或8KB是合理的起点。
- **【推荐】** 考虑消息的序列化/反序列化性能。对于性能敏感的应用，Protobuf (`protobuf-net`) 等二进制格式通常优于 JSON (`System.Text.Json`)。如果使用JSON，`System.Text.Json` 通常比 `Newtonsoft.Json` 性能更好。
- **【推荐】** 谨慎使用 `CancellationToken`。虽然对于取消操作至关重要，但过度创建和传递 `CancellationTokenSource` 和 `Token` 也会有轻微开销。合理管理 `CancellationTokenSource` 的生命周期。
- **【推荐】** 对于高吞吐量场景，考虑使用 `System.IO.Pipelines` 配合 `ClientWebSocket` 进行更高效的流式数据处理，但这会增加实现的复杂性。

---

## 五、最佳实践

- **【强制】** 所有涉及网络IO的操作（连接、发送、接收、关闭）必须使用异步方法 (`async/await`)，并正确传递 `CancellationToken` 以支持取消和超时。
- **【推荐】** 将 WebSocket 通信逻辑封装在专门的服务类或管理器中（例如 `WebSocketClientManager`），而不是直接散布在业务代码中。这个类应该负责连接管理、消息收发、重连、心跳等。
    - 该服务应通过依赖注入（DI）来使用，并管理其自身的生命周期。
    - **生命周期**: 通常建议将 `WebSocketClientManager` 注册为 `Singleton`，如果它需要维护一个持久的、共享的连接。如果每个用户或会话需要独立的连接，则可以是 `Scoped`。
    - **配置**: 应通过 `IOptions<WebSocketOptions>` 注入配置 (URI, timeouts, retry settings, etc.)，遵循 `@dotnet-code-development-and-quality.mdc` 的配置规范。
- **【推荐】** 提供清晰的事件或回调机制 (例如 `Action<MessageEventArgs>`, `IObservable<TMessage>`)，供应用层订阅连接状态变化（连接成功、断开、重连中）、接收到消息、发生错误等事件。
- **【推荐】** 代码应具备良好的可读性和可维护性，添加必要的XML文档注释，遵循 `@dotnet-code-development-and-quality.mdc`。
- **【推荐】** 对于复杂的交互，考虑定义清晰的应用层协议（消息类型、数据结构、请求-响应模式（如果需要）等）。
- **【推荐】** 确保所有异步操作都有错误处理路径，并且长时间运行的任务（如接收循环、重连循环）可以被正确取消。

---

## 六、与项目规范的集成

### 6.1 项目结构与定位
- 根据 `@dotnet-project-architecture-and-structure.mdc` 规范：
    - 通用的 `WebSocketClientManager` 或类似的基础设施组件，如果其不包含特定业务逻辑，可以放在 `SolutionName.Infrastructure` 项目中。
    - 如果 WebSocket 客户端紧密服务于特定的应用层功能，并且协调领域逻辑或应用状态，其管理器或协调服务可以放在 `SolutionName.Application` 项目中，并依赖于基础设施层提供的更底层的 WebSocket 连接能力（如果分离）。
    - 配置（如 `WebSocketOptions`）应遵循 Options 模式，在 `Program.cs` 或 `Startup.cs` 中注册。

### 6.2 错误处理与日志记录
- **【强制】** 全面遵循 `@dotnet-error-handling-and-operations.mdc`。
    - **异常**：WebSocket 相关的异常（如连接失败、发送/接收错误、超时）应被捕获，并根据需要转换为 `BizException` 或其他应用定义的标准异常类型，携带明确的错误码。
    - **日志**：所有重要的 WebSocket 事件（连接、断开、重连尝试、消息收发、错误）都必须使用 `ILogger` 进行结构化日志记录，包含必要的上下文信息和Trace ID。

### 6.3 编码与质量规范
- **【强制】** 所有 WebSocket 客户端相关的代码实现（包括管理器类、辅助类、DTO等）必须遵循 `@dotnet-code-development-and-quality.mdc` 中定义的：
    - 命名规范。
    - 方法设计原则 (原子性、可读性、分层)。
    - 异步编程最佳实践 (`async/await`, `CancellationToken`)。
    - 依赖注入 (使用构造函数注入 `ILogger`, `IOptions`, 其他服务)。
    - XML 文档注释。
    - 代码格式和编码实践。
- **【强制】** 相关的业务逻辑或应用服务，如果使用了 WebSocket 客户端，其单元测试和集成测试必须覆盖 WebSocket 的交互场景（可能通过Mocking WebSocket管理器或使用测试服务器）。

---

> 本规范为 .NET WebSocket 客户端开发提供指导。在具体项目中，应结合实际需求和团队约定进行调整和细化。

