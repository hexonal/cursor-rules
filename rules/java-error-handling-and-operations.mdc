---
description: 
globs: 
alwaysApply: true
---
---
description: 
globs: 
alwaysApply: true
---
# Java项目错误码与异常处理规范

本规则基于阿里巴巴Java开发手册和现有项目规范，专注于错误码定义、异常处理、日志记录等方面的最佳实践。

## 错误码规范
### 【强制】错误码格式
1. 错误码为5位数字，格式为：`[A][BB][CC]`
   - A：错误级别，1-系统级，2-服务级，3-业务级
   - BB：模块编号，如：01-用户，02-订单
   - CC：具体错误编号，如：01-参数错误，02-权限不足
2. 示例：10101-系统级用户模块参数错误

### 【强制】错误码定义
1. 错误码必须在枚举类中统一定义
2. 错误码枚举类必须实现 IErrorCode 接口
3. 错误码必须有清晰的注释说明
4. 错误码必须有对应的错误信息模板

### 【强制】错误码分类
1. 系统级错误（1xxxx）
   - 10000：系统未知异常
   - 10001：系统维护中
   - 10002：服务暂时不可用
   - 10003：系统繁忙，请稍后重试
2. 服务级错误（2xxxx）
   - 20001：参数校验失败
   - 20002：接口调用失败
   - 20003：数据库操作失败
   - 20004：缓存操作失败
3. 业务级错误（3xxxx）
   - 30001：用户未登录
   - 30002：权限不足
   - 30003：操作频繁
   - 30004：资源不存在

### 【推荐】错误码唯一性保障与维护机制
*   **【推荐】** 考虑建立项目内或跨服务的错误码管理机制（如统一文档、Wiki页面、或专用配置管理），以确保错误码的唯一性并记录其含义、版本和状态（如新增、使用中、待废弃）。
*   **【推荐】** 规范错误码的申请、审批、变更、废弃流程，确保错误码的变更得到有效追踪和通知。

## 异常处理规范

### 【强制】异常分类
1. 业务异常：BizException，用于处理可预期的业务错误
2. 系统异常：SystemException，用于处理不可预期的系统错误
3. 参数异常：IllegalArgumentException，用于处理参数校验错误

### 【强制】异常处理原则
1. 禁止直接抛出 new RuntimeException()
2. 禁止捕获异常后不处理或打印
3. 禁止在 finally 块中抛出异常
4. 禁止在循环中抛出异常
5. 禁止直接使用 Throwable 和 Exception 捕获异常

### 【强制】异常处理方式
1. Controller 层：
   - 统一使用 @RestControllerAdvice 处理异常
   - 必须对所有已知异常进行处理
   - 必须有统一的未知异常处理
2. Service 层：
   - 只抛出业务异常
   - 必须转换第三方异常为自定义异常
   - 必须处理事务异常
3. DAO 层：
   - 只处理数据库相关异常
   - 必须转换 SQL 异常为自定义异常
4. 工具类：
   - 抛出具体异常，不做统一处理
   - 必须在文档中说明可能抛出的异常

## 日志规范

### 【强制】日志配置
1. 必须使用 SLF4J + Logback 组合
2. 必须按照不同级别配置日志
3. 必须按照日期切分日志文件
4. 必须配置异步日志提高性能
5. 必须配置日志保留时间

### 【强制】日志级别使用规范
1. ERROR：系统级严重错误，影响系统正常运行
2. WARN：业务级警告，不影响系统正常运行
3. INFO：重要业务操作信息
4. DEBUG：开发调试信息，生产环境关闭
5. TRACE：仅用于开发环境，生产环境禁用

### 【强制】日志内容规范
1. **语言与清晰度**：
   *   日志信息应主要使用**中文**，确保清晰、准确、易于理解。
   *   避免使用模棱两可或过于简略的表述。
2. **变量处理与占位符**：
   *   **必须使用 SLF4J 的参数化日志方式**，即使用占位符 `{}`，而不是字符串拼接。例如：
       ```java
       // 正确示例
       log.info("用户 {} 尝试登录，结果：{}", userId, loginStatus);
       log.error("处理订单 {} 发生错误，错误码：{}，详情：{}", orderId, errorCode, detailInfo, exception);

       // 错误示例 (禁止字符串拼接)
       // log.info("用户 " + userId + " 尝试登录，结果：" + loginStatus);
       ```
   *   这样做可以提高性能（仅在日志级别允许时才进行字符串格式化），并增强日志的可读性和后续分析的便利性。
3. **核心业务信息**：
   *   必须记录关键业务操作的**入参**和**出参**（或关键结果）。对于复杂对象，可选择记录其核心字段或 `toString()`（确保 `toString()` 实现不包含敏感信息且可读性好）。
   *   必须记录重要状态的变更信息，例如订单状态流转、用户状态变化等。
4. **异常信息**：
   *   记录异常时，必须包含完整的异常堆栈信息，以便于定位问题根源。通常日志框架的 `error(String msg, Throwable t)` 方法会自动处理。
5. **追踪信息**：
   *   必须包含追踪信息，如请求ID（Trace ID）、用户ID（若适用）、会话ID等，以便于在分布式系统中追踪完整的调用链。
6. **敏感信息处理**：
   *   **严禁**在日志中记录明文的敏感信息，如用户密码、完整的身份证号、银行卡号、密钥、Token等。如果业务分析确实需要某些敏感信息的片段或脱敏形式，必须按照公司安全规范进行严格的脱敏处理。参考"七、安全规范"中的"日志安全"。

### 【强制】日志格式规范
1. 时间戳：yyyy-MM-dd HH:mm:ss.SSS
2. 日志级别：ERROR/WARN/INFO/DEBUG/TRACE
3. 进程ID：[PID]
4. 线程名：[ThreadName]
5. 类名：完整类名
6. 方法名：方法名
7. 行号：行号
8. 消息体：具体日志信息

### 【推荐】关键错误告警机制
*   **【推荐】** 对于严重影响系统稳定运行的 `ERROR` 级别日志事件，或特定的、代表关键业务失败的错误码，应建立有效的监控告警机制（如通过日志系统对接Prometheus、Grafana、ELK Stack告警功能，或企业级监控平台）。
*   **【推荐】** 告警应能及时通知到相关的开发和运维人员，确保生产问题得到快速响应和处理。

## 统一响应规范

### 【强制】响应格式
```java
public class Result<T> {
    private Integer code;      // 状态码
    private String message;    // 提示信息
    private T data;           // 响应数据
    private Long timestamp;   // 响应时间戳
    private String traceId;   // 请求追踪ID
}
```

### 【强制】响应状态码
1. 200：成功
2. 400：客户端错误（参数错误）
3. 401：未授权
4. 403：禁止访问
5. 404：资源不存在
6. 429：请求过于频繁
7. 500：服务器内部错误

### 【强制】异常响应处理
1. 统一使用 Result 包装响应数据
2. 异常必须转换为对应的错误码
3. 系统异常统一返回 500 错误码
4. 业务异常返回具体业务错误码
5. 必须包含请求追踪ID
6. **【推荐】** 面向用户的错误提示（如 `Result.message`）应友好、简洁、不包含敏感技术细节或内部错误码。详细的技术错误信息、内部错误码和异常堆栈必须只记录在服务端日志中，供内部排查使用。

## 参数校验规范

### 【强制】校验方式
1. 使用 JSR303 注解进行参数校验
2. Controller 层必须使用 @Valid 注解
3. Service 层必须进行业务参数校验
4. 自定义校验注解必须实现 ConstraintValidator
5. 必须使用统一的参数校验处理器

### 【强制】校验规则
1. 必填字段：@NotNull, @NotEmpty, @NotBlank
2. 长度限制：@Length, @Size
3. 范围限制：@Min, @Max, @Range
4. 格式校验：@Email, @Pattern
5. 自定义校验：根据业务需求实现

## 安全规范

### 【强制】异常信息处理
1. 生产环境禁止直接返回异常堆栈信息
2. 敏感信息必须脱敏后记录日志
3. 异常信息必须规范化后返回给用户
4. 系统异常统一返回"系统繁忙"
5. 必须记录完整异常堆栈到日志系统 

## 八、弹性设计与容错（可选）

### 【可选】超时、重试与断路器
*   **【推荐】** 对于外部依赖调用（如HTTP API、RPC服务、数据库、消息队列等），应考虑引入弹性设计模式以提高系统的容错性和可用性：
    *   **超时控制**：为所有外部调用设置合理的超时时间，避免无限等待导致资源耗尽。
    *   **重试机制**：对瞬时性、网络抖动等可恢复的错误，实施带退避策略（如指数退避）的有限次数重试。重试仅适用于幂等操作。
    *   **断路器模式**：当某个依赖持续失败达到阈值时，断路器打开，后续请求快速失败或执行降级逻辑，避免对故障依赖的进一步冲击，并在一段时间后尝试恢复。可考虑使用如 Resilience4j 等库实现。
    *   **服务降级**：在依赖服务故障或性能下降时，提供备用方案或返回默认/缓存数据，保证核心功能的可用性。 