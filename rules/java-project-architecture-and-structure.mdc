---
description: 
globs: 
alwaysApply: true
---
# Java项目架构与结构规范

本规范旨在统一Java项目的架构设计、模块划分、代码结构、分支管理和版本控制等方面，以充分利用Java 21的新特性，提高项目的可维护性、可扩展性和团队协作效率。

## 一、基础框架要求

### 【强制】技术栈版本
1. Java版本：21
2. Spring Boot：3.2+ (支持Java 21)
3. Dubbo：3.2+ (支持Java 21虚拟线程)
4. Nacos：2.2.3+
5. Apollo：2.1.0+
6. Redis客户端：Lettuce 6.3+ (支持虚拟线程)
7. MySQL：8.0+
8. Elasticsearch：8.11+
9. MongoDB：6.0+
10. RocketMQ：5.1+
11. XXL-JOB：2.4.0
12. Maven：3.9.5+
13. Resilience4j：2.1.0+ (支持虚拟线程)
14. Log4j2：2.22.0+

### 【强制】项目特性
1. 所有项目必须是多模块项目
2. 必须使用 Spring Boot 3.x Starter 进行项目初始化
3. 必须使用 MyBatis-Plus 3.5.4+ 进行数据库操作
4. 必须使用 Log4j2 进行日志记录
5. 必须使用 Apollo 进行配置管理
6. 必须利用Java 21虚拟线程优化I/O密集型操作：
   - **适用场景**：优先用于执行大量并发的、主要时间消耗在等待外部资源（如网络请求、文件I/O、数据库查询、消息队列收发等）的任务。
   - **实现方式**：通过 `Executors.newVirtualThreadPerTaskExecutor()` 创建执行器，或依赖框架（如Spring Boot 3.2+, Dubbo 3.2+, Lettuce 6.3+）对虚拟线程的内建支持。
   - **注意事项**：避免在虚拟线程中执行长时间占用CPU的计算密集型任务。注意同步代码块（`synchronized`）可能导致平台线程被固定（pinned），应优先使用 `java.util.concurrent.locks.ReentrantLock`。
7. 必须使用结构化并发API（Structured Concurrency, JEP 453）管理复杂的并发任务：
   - **适用场景**：当一个任务分解为多个并发子任务，并且需要对这些子任务的生命周期（如全部成功、任一成功、超时、错误处理、取消）进行统一、可靠的管理时。例如，并行调用多个下游服务并聚合结果。
   - **实现方式**：使用 `StructuredTaskScope` 及其派生类（如 `ShutdownOnFailure`, `ShutdownOnSuccess`）来编排并发子任务。
   - **优势**：简化并发编程模型，提高代码可读性和可维护性，通过作用域来保证线程行为的原子性和资源清理的及时性，避免线程泄漏。

## 二、项目结构规范

### 【强制】模块划分
1. api 模块：对外提供的接口和模型定义
   - 包含接口定义
   - 包含请求/响应对象
   - 包含枚举定义
2. api-impl 模块：接口实现
   - 包含接口实现类
   - 包含业务逻辑处理
3. biz 模块：核心业务逻辑
   - 包含业务处理类
   - 包含领域模型
   - 包含业务工具类
4. common 模块：公共组件
   - 包含工具类
   - 包含常量定义
   - 包含通用配置
5. dao 模块：数据访问层
   - 包含实体类
   - 包含Mapper接口
   - 包含XML映射文件
6. integration 模块：外部集成
   - 包含第三方接口调用
   - 包含外部服务集成
7. web 模块：Web层
   - 包含Controller
   - 包含拦截器
   - 包含配置类

### 【强制】包结构规范
1. 基础包名：com.hex
2. 模块包名：
   ```
   com.hex.api          // API定义
     ├── {模块}.service      // RPC服务接口
     ├── {模块}.request      // 请求对象
     └── {模块}.response     // 响应对象

   com.hex.api.impl     // API实现
     └── {模块}.service.impl // RPC服务实现

   com.hex.biz          // 业务逻辑
     ├── {模块}.service      // 业务服务
     ├── {模块}.dto         // 数据传输对象
     ├── {模块}.job         // 定时任务
     ├── {模块}.ons.consumer // 消息消费者
     ├── {模块}.ons.producer // 消息生产者
     └── {模块}.ons.service  // 消息服务

   com.hex.dao          // 数据访问
     ├── {模块}.entity      // 实体类
     ├── {模块}.mapper      // MyBatis接口
     ├── {模块}.dao        // 数据访问对象
     └── {模块}.bo         // 业务对象

   com.hex.integration  // 外部集成
     ├── {模块}.service     // 集成服务
     ├── {模块}.request     // 请求对象
     └── {模块}.response    // 响应对象

   com.hex.common       // 公共组件
     ├── constants          // 常量定义
     ├── enums             // 枚举定义
     ├── utils             // 工具类
     └── exception         // 异常类

   com.hex.web          // Web层
     ├── {模块}.controller  // 控制器
     ├── {模块}.request     // 请求对象
     ├── {模块}.response    // 响应对象
     ├── interceptor       // 拦截器
     └── config            // 配置类
   ```

### 【强制】资源文件规范
1. 配置文件位置：
   ```
   resources/
     ├── application.yml        // 主配置文件
     ├── application-dev.yml    // 开发环境配置
     ├── application-test.yml   // 测试环境配置
     ├── application-prod.yml   // 生产环境配置
     └── logback-spring.xml    // 日志配置
   ```
2. MyBatis映射文件位置：
   ```
   resources/
     └── mapper/
         └── 业务模块名/
             └── XxxMapper.xml
   ```

## 三、分支管理与版本控制规范

### 【强制】分支命名规范
1. 主分支：master
2. 开发分支：develop
3. 功能分支：feature/模块名/功能描述
4. 修复分支：hotfix/问题描述
5. 发布分支：release/版本号

### 【强制】分支策略
1. master分支：
   - 生产环境代码
   - 只能从release分支合并
   - 每次合并必须打tag
2. develop分支：
   - 开发环境代码
   - 功能开发的基础分支
   - 只能从feature分支合并
3. feature分支：
   - 从develop分支创建
   - 完成后合并回develop
   - 命名规范：feature/模块名/功能描述
4. hotfix分支：
   - 从master分支创建
   - 完成后同时合并到master和develop
   - 命名规范：hotfix/问题描述
5. release分支：
   - 从develop分支创建
   - 完成后合并到master和develop
   - 命名规范：release/版本号

### 【强制】版本号格式
1. 格式：主版本号.次版本号.修订号
2. 主版本号：不兼容的API修改
3. 次版本号：向下兼容的功能性新增
4. 修订号：向下兼容的问题修正

### 【强制】版本发布流程
1. 准备阶段：
   - 创建release分支
   - 更新版本号
   - 更新CHANGELOG
2. 测试阶段：
   - 完整回归测试
   - 修复发现的问题
   - 更新文档
3. 发布阶段：
   - 合并到master
   - 打tag
   - 部署生产环境
4. 完成阶段：
   - 合并到develop
   - 删除release分支
   - 发布公告

### 【强制】Tag管理
1. 命名规范：
   - v主版本号.次版本号.修订号
   - 示例：v1.2.3
2. 标记要求：
   - 必须有描述信息
   - 必须关联提交ID
   - 必须有发布说明
3. 管理要求：
   - 禁止删除已发布tag
   - 禁止修改已发布tag
   - 及时同步到远程仓库

### 【强制】依赖管理规范
1. 版本管理
   - 统一在父POM中定义版本
   - 禁止在子模块中指定版本
   - 必须使用版本管理插件
   - 定期更新依赖版本
   - **【推荐】** 积极使用BOM (Bill of Materials) 文件管理相关依赖集合的版本。例如，`spring-boot-dependencies` BOM，以及为项目内部一组模块定义的BOM。这有助于统一版本、简化依赖声明并减少版本冲突。
2. 依赖原则
   - 避免依赖冲突
   - 避免循环依赖
   - 避免过度依赖
   - 及时清理无用依赖

## 四、构建与交付规范

### 【推荐】构建与CI/CD质量门禁
*   **自动化构建**：使用Maven或Gradle进行标准化、可重复的自动化构建。
*   **持续集成 (CI)**：
    *   代码提交后自动触发构建、单元测试和集成测试。
    *   集成静态代码分析工具（如SonarQube, Checkstyle, PMD）进行代码质量扫描，设定质量门禁（如Bugs数量、漏洞、代码异味、测试覆盖率阈值）。
    *   集成安全扫描工具（如依赖漏洞扫描、SAST工具）。
*   **测试覆盖率**：设定明确的单元测试和集成测试覆盖率目标（如行覆盖率、分支覆盖率），并作为CI流程中的质量门禁。
*   **制品管理**：构建产生的制品（如JAR包、Docker镜像）应存储在制品仓库（如Nexus, Artifactory, Harbor）中，并进行版本化管理。
*   **持续交付/部署 (CD)**：
    *   实现从代码提交到生产（或预生产）环境的自动化或半自动化部署流程。
    *   采用蓝绿部署、金丝雀发布等策略降低部署风险。
    *   部署过程应包含健康检查和快速回滚机制。

### 【推荐】配置管理 (Apollo) 使用细则
*   **Namespace规划**：
    *   应用自有配置 ( `application` )：存放应用自身的配置项，如数据库连接、线程池大小等。此Namespace对应用私有。
    *   公共配置：对于多个应用共享的配置（如通用错误码、中间件地址、特性开关等），应创建专门的公共Namespace（如 `common.utils`, `middleware.config`）。应用按需关联这些公共Namespace。
    *   命名规范：Namespace名称应清晰表意，如 `项目名.模块名` 或 `业务领域.配置类型`。
*   **配置项命名**：
    *   采用与Spring Boot类似的层级化命名方式，如 `spring.datasource.url`, `custom.feature.switchA`。
    *   保持一致性，使用小写字母和点 (`.`) 分隔。
*   **敏感配置处理**：
    *   **【强制】** 密码、密钥等极敏感信息不应明文存储在Apollo中。应考虑使用Apollo的加密功能，或结合外部加密服务/环境变量注入等方式处理。
    *   对于一般敏感信息，可利用Apollo的权限控制，限制其访问和修改权限。
*   **配置发布与回滚**：
    *   遵循灰度发布原则：先在预发/测试环境验证配置变更，再逐步推向生产环境。
    *   利用Apollo的版本和发布历史功能，确保配置变更可追溯，并在必要时能够快速回滚到先前版本。
    *   配置变更时，应有相应的变更说明和审批流程。
*   **监听与动态刷新**：
    *   对于需要动态刷新的配置项（如通过 `@ConfigurationProperties` 或 `@Value` 注入的），确保应用正确配置了Apollo的动态刷新机制。
    *   注意动态刷新可能带来的影响，如连接池重建、缓存失效等，应在设计时予以考虑。

### 【推荐】架构层面的安全性设计原则
*   **默认安全 (Secure by Default)**：系统设计应默认开启安全配置，需要显式操作才能降低安全级别。避免不安全的默认设置。
*   **最小权限原则 (Principle of Least Privilege)**：无论是用户账户、服务账户还是系统组件，都只授予其完成任务所必需的最小权限集。
*   **纵深防御 (Defense in Depth)**：不依赖单一安全措施。通过多层、多样化的安全控制（如网络防火墙、WAF、主机安全、应用层安全、数据加密等）构建防护体系。
*   **输入校验与输出编码**：
    *   严格校验所有不可信来源的输入（包括用户输入、API请求、第三方系统数据），防止注入、溢出等攻击。（参见 `@yupao-http-api.mdc` 和 `@yupao-error-handling-and-operations.mdc`）
    *   对输出到不同上下文（如HTML页面、日志、数据库查询）的数据进行恰当的编码或转义，防止XSS、日志注入等问题。
*   **依赖安全管理**：
    *   定期扫描项目依赖，及时发现并修复已知的安全漏洞（CVEs）。使用工具（如OWASP Dependency-Check, Snyk）辅助检查。
    *   仅从可信来源获取依赖，并验证其完整性。
*   **认证与授权强化**：确保所有接口和资源访问都有强认证和细粒度授权机制。（参见 `@yupao-http-api.mdc`）
*   **敏感数据保护**：对静态存储和传输过程中的敏感数据（如个人信息、支付信息、密钥）进行加密保护。实施恰当的密钥管理策略。
*   **安全审计与日志**：记录关键安全事件（如登录尝试、权限变更、重要操作），并对安全日志进行监控和分析，以便及时发现和响应安全事件。（参见 `@yupao-error-handling-and-operations.mdc`）