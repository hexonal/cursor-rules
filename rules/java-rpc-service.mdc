---
description: 
globs: 
alwaysApply: true
---
# Java项目RPC服务规范

本规则基于现有项目规范，专注于RPC接口的设计、实现和调用规范。

## 一、RPC接口规范 (服务端)

### 【强制】接口定义规范
1. 接口命名与参数规范：
   ```java
   public interface UserRpcService {
       // 正确实例
       Result<UserRpcResp> getUser(UserRpcReq req);
       //错误实例
       //UserResp getUser(UserRpcReq req);
   }
   ```
   (注意：此处的 Result 是指 `@com.hexonal.commons.base.Result`，其使用应遵循 `@java-error-handling-and-operations.mdc` 中关于统一响应体Result的规范。RPC的Req/Resp对象应定义在xxx-api模块。)

### 【强制】接口实现规范
1. 实现类命名：
   ```java
   @DubboService
   @RequiredArgsConstructor
   public class UserRpcServiceImpl extends BaseRpcService implements UserRpcService {
       private final UserBizService userBizService;
       // 实现方法
       public Result<UserRpcResp> getUser(UserRpcReq req){
         return rpcResult(() -> {
            // 场景1: UserRpcReq直接适用于UserBizService (应用服务)
            // UserRpcRespDTO userBizResp = userBizService.getUserDetails(req); // 假设UserBizService接受UserRpcReq
            // return XBeanCopier.copyProperties(userBizResp, UserRpcResp.class);

            // 场景2: UserRpcReq需要映射到UserBizService的不同DTO (更常见于解耦)
            UserBizServiceReqDTO bizReqDto = XBeanCopier.copyProperties(req, UserBizServiceReqDTO.class);
            UserBizServiceRespDTO bizRespDto = userBizService.getUserDetails(bizReqDto); // userBizService是应用服务
            return XBeanCopier.copyProperties(bizRespDto, UserRpcResp.class);
        });
   }
   ```

2. 实现要求：
   - 必须添加 `@DubboService` 注解 (并按需配置其属性如 `version`, `group`, `timeout`, `retries` 等，优先通过配置中心管理这些属性值)。
   - 优先使用 `final` 修饰依赖
   - 必须继承 `BaseRpcService` (其 `rpcResult` 方法应负责捕获来自 `userBizService` 的已知异常如 `BizException`、`SystemException`，并将其转换为 `Result` 对象中的code和message)。
   - 必须实现接口中所有方法
   - 必须处理所有异常场景 (参考 `@java-error-handling-and-operations.mdc`)
   - 必须添加方法注释 (参考 `@java-code-development-and-quality.mdc`)
   - 必须进行参数校验 (参考 `@java-error-handling-and-operations.mdc`)

### 【强制】接口版本控制
1. 接口升级原则：
   ```java
   public interface UserRpcService {
       // V1版本接口
       @Deprecated
       Result<UserRpcResp> getUser(Long userId); // 假设旧版接口
       
       // V2版本接口，增加了缓存参数或修改了请求体
       Result<UserRpcResp> getUser(UserRpcReq req); // 新版接口使用请求对象
   }
   ```

2. 版本号管理：
   - 主版本号：不兼容的API修改 (例如，方法签名改变，字段删除/类型改变)。**【强制】**不兼容的修改必须使用新的Dubbo服务版本号 (如 `@DubboService(version = "2.0.0")`)，旧版本可标记 `@Deprecated` 并逐步下线。
   - 次版本号：向下兼容的功能性新增 (例如，在请求对象中增加可选字段，在响应对象中增加新字段)。通常可使用相同的Dubbo服务版本号，或按需升级次版本。
   - 修订号：向下兼容的问题修正。通常可使用相同的Dubbo服务版本号。
   - **【核心】** Dubbo的 `version` 属性是管理服务多版本的关键。避免在同一接口内通过不同方法名来表示同一业务操作的不同版本。

### 【强制】接口安全规范
1. 参数校验： (参考 `@java-error-handling-and-operations.mdc` 中的参数校验规范)
   ```java
   public class UserRpcReq {
       @NotNull(message = "用户ID不能为空")
       private Long userId;
       
       @NotBlank(message = "用户名不能为空")
       @Length(min = 2, max = 20, message = "用户名长度必须在2-20之间")
       private String username;
       // 其他业务参数...
   }
   ```

## 二、业务方调用RPC接口规范 (客户端/调用方)

### 【强制】接口定义规范 (Proxy Service)
1. 接口命名与参数规范：
   ```java
   public interface UserRpcProxyService {
       // 错误实例
       //Result<UserRpcResp> getUser(UserRpcReq req);
       //正确实例
       UserRpcResp getUser(UserRpcReq req);
   }
   ```
   (注意：调用方封装后的方法通常直接返回业务数据 `UserRpcResp`，`Result` 的解析在实现类中完成)

### 【强制】接口实现规范 (Proxy Service Impl)
1. 实现类命名：
   ```java
   @Service
   @RequiredArgsConstructor // 推荐使用构造器注入
   public class UserRpcProxyServiceImpl extends BaseRpcService implements UserRpcProxyService {
       @DubboReference //(version = "1.0.0", group = "xxx") // 按需指定版本和分组
       private UserRpcService userRpcService; // UserRpcService 为RPC服务端定义的接口

       // 实现方法
       @Override
       public UserRpcResp getUser(UserRpcReq req){
          // 参数校验 (如果适用，例如对 req 的某些字段有特定于调用方的校验)
          // if (req.getSomeClientSpecificField() == null) { ... }
          // BaseRpcService.parseResult应处理来自RPC调用的Result，如果Result表示失败，则抛出客户端异常
          return super.parseResult(() -> userRpcService.getUser(req));
       }
   }
   ```

2. 实现要求：
   - 必须添加 `@Service` 注解 (Spring Service)
   - 必须使用 `@DubboReference` 注入RPC服务
   - 推荐继承 `BaseRpcService` (如果提供了 `parseResult` 等通用逻辑)
   - 必须实现接口中所有方法
   - 必须处理所有异常场景，特别是RPC调用异常 (例如 `RpcException` 或由 `BaseRpcService.parseResult` 抛出的自定义客户端业务异常)。处理逻辑应遵循 `@java-error-handling-and-operations.mdc`。
   - 必须添加方法注释 (参考 `@java-code-development-and-quality.mdc`)
   - 可选进行调用方特有的参数校验

---
**附注：**
*   **事务边界**：RPC服务端的方法 (`XxxRpcServiceImpl`) 通常是一个完整的事务单元（如果操作涉及写库）。客户端调用RPC服务时，不应期望其能加入到客户端的本地事务中。
*   **幂等性**：对于可能被重试的写操作RPC接口，服务端应设计为幂等的。客户端可在 `XxxRpcReq` 中传递幂等性令牌，服务端进行处理。参考 `@java-http-api.mdc` 中关于幂等性的建议。
*   **超时与重试**：客户端 (`@DubboReference`) 和服务端 (`@DubboService`) 均可配置超时时间和重试次数。应根据接口的特性（读/写，耗时）和网络环境合理配置，避免不当重试导致数据不一致或雪崩效应。配置值建议通过Apollo配置中心管理。