---
description: 
globs: 
alwaysApply: true
---
# Java项目设计模式应用指南

本指南旨在提供Java项目中常用设计模式的理解和应用场景，以提升代码的可维护性、可扩展性、可读性和团队整体的CR（Code Review）能力。设计模式的运用应与 `@yupao-code-development-and-quality.mdc`（特别是其中关于DDD和充血模型的指导）以及 `@yupao-project-architecture-and-structure.mdc` 紧密结合，共同促进高质量软件的交付。

## 一、设计模式核心原则

在应用设计模式之前，应深刻理解以下核心设计原则，它们是设计模式的基础：

1.  **单一职责原则 (SRP - Single Responsibility Principle)**：一个类应该只有一个引起它变化的原因。
2.  **开闭原则 (OCP - Open/Closed Principle)**：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。
3.  **里氏替换原则 (LSP - Liskov Substitution Principle)**：所有引用基类（父类）的地方必须能透明地使用其子类的对象。
4.  **接口隔离原则 (ISP - Interface Segregation Principle)**：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。
5.  **依赖倒置原则 (DIP - Dependency Inversion Principle)**：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。

**强调：设计模式是解决特定问题的成熟方案，但不是万能药。应避免过度设计，只有在确实能带来明确收益（如提高灵活性、降低耦合度、增强可读性）时才考虑引入。**

## 二、常用设计模式及其在项目中的应用

以下设计模式在的Java项目中较为常用，尤其是在结合DDD思想进行开发时。

### 2.1 创建型模式

#### 1. 工厂方法模式 (Factory Method)
*   **意图**：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
*   **应用场景**：
    *   当一个类不知道它所必须创建的对象的类的时候。
    *   当一个类希望由它的子类来指定它所创建的对象的时候。
    *   在DDD中，复杂聚合根或实体的创建，特别是当创建过程涉及一些业务规则或需要依赖其他服务时，可以由专门的工厂类（`XxxFactory`）负责。例如，`OrderFactory` 可以根据不同的输入参数（如订单类型、促销活动）创建不同配置的 `Order` 实体。
    *   **示例（结合DDD的实体创建）**：
        ```java
        // OrderFactory.java (位于 domain.model.order 或 domain.factory)
        @Component // 如果需要注入依赖
        public class OrderFactory {
            private final ProductRepository productRepository; // 示例依赖
            private final UserDiscountService userDiscountService; // 示例依赖

            @Autowired
            public OrderFactory(ProductRepository productRepository, UserDiscountService userDiscountService) {
                this.productRepository = productRepository;
                this.userDiscountService = userDiscountService;
            }

            public Order createNewOrder(CreateOrderReq dto, Long userId) {
                // 复杂的创建逻辑，可能涉及校验、获取外部信息、应用规则等
                List<OrderItem> items = dto.getItems().stream()
                                          .map(itemDto -> {
                                              ProductSnapshot product = productRepository.findProductSnapshotById(itemDto.getProductId());
                                              if (product == null) throw new BizException(BizErrorCode.PRODUCT_NOT_FOUND);
                                              return new OrderItem(product, itemDto.getQuantity());
                                          })
                                          .collect(Collectors.toList());
                
                Money initialTotal = calculateInitialTotal(items);
                Discount applicableDiscount = userDiscountService.getApplicableDiscount(userId, initialTotal);
                Money finalTotal = initialTotal.applyDiscount(applicableDiscount);

                Order order = new Order(userId, items, finalTotal, dto.getShippingAddress());
                order.generateOrderNumber(); // 实体自身行为
                // order.applyInitialPromotions(); // 更多实体行为
                return order;
            }

            private Money calculateInitialTotal(List<OrderItem> items) {
                // ... 计算逻辑
                return new Money(BigDecimal.ZERO, Currency.CNY); // 示例
            }
        }
        ```

#### 2. 抽象工厂模式 (Abstract Factory)
*   **意图**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
*   **应用场景**：
    *   当一个系统要独立于它的产品的创建、组合和表示时。
    *   当一个系统要由多个产品系列中的一个来配置时。
    *   当你要强调一系列相关的产品对象的设计以便进行联合使用时。
    *   例如，如果系统支持多种UI主题（每种主题包含一套按钮、文本框等组件），或者支持多种持久化方案（每种方案有一套DAO实现）。

#### 3.建造者模式 (Builder)
*   **意图**：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
*   **应用场景**：
    *   当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
    *   当构造过程必须允许被构造的对象有不同的表示时。
    *   尤其适用于创建具有多个可选参数或配置步骤的对象，避免构造函数参数过多或Setter方法状态不一致的问题。
    *   在DTO或领域实体创建时，如果构造参数较多，可使用Lombok的 `@Builder` 注解或手写Builder。
    *   **示例（领域实体或DTO）**：
        ```java
        // UserProfile.java (领域实体或值对象)
        @Builder
        @Getter
        public class UserProfile {
            private final String nickname;
            private final String avatarUrl;
            private final Gender gender;
            private final LocalDate birthday;
            private final String bio;
            // ... 其他方法和业务逻辑
        }

        // 使用
        UserProfile profile = UserProfile.builder()
                                .nickname("FishPa")
                                .avatarUrl("http://example.com/avatar.png")
                                .gender(Gender.MALE)
                                // bio 未设置则为null或默认值
                                .build();
        ```

#### 4. 单例模式 (Singleton)
*   **意图**：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
*   **应用场景**：
    *   **谨慎使用**。在Spring框架管理下，Bean默认是单例的，通常不需要手动实现单例模式。
    *   如果确实有全局唯一且无状态的组件不由Spring管理，可以考虑。但多数情况下，应优先考虑通过Spring的依赖注入来管理对象生命周期。

### 2.2 结构型模式

#### 1. 适配器模式 (Adapter)
*   **意图**：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
*   **应用场景**：
    *   当你希望使用某些现有类，但其接口与其他代码不兼容时。
    *   在DDD中，**防腐层 (Anti-Corruption Layer, ACL)** 的实现常采用适配器模式，用于隔离外部系统（如第三方API、旧系统）的变化对本限界上下文的影响。
    *   例如，调用外部支付网关，其API可能与项目内部的支付服务接口不一致，可以创建一个 `PaymentGatewayAdapter` 来适配。
    *   **示例（防腐层）**：
        ```java
        // 假设外部支付网关SDK接口
        // public class ExternalPaymentSDK {
        //     public SDKPaymentResponse initiatePayment(SDKPaymentRequest sdkRequest);
        // }

        // 项目内部统一的支付服务接口
        public interface PaymentService {
            PaymentResult makePayment(PaymentCommand command);
        }

        // 适配器实现
        @Service
        public class ExternalPaymentAdapter implements PaymentService {
            private final ExternalPaymentSDK externalSdk; // 通过构造器注入

            @Autowired
            public ExternalPaymentAdapter(ExternalPaymentSDK externalSdk) {
                this.externalSdk = externalSdk;
            }

            @Override
            public PaymentResult makePayment(PaymentCommand command) {
                SDKPaymentRequest sdkRequest = convertToSdkRequest(command); // 转换逻辑
                SDKPaymentResponse sdkResponse = externalSdk.initiatePayment(sdkRequest);
                return convertToPaymentResult(sdkResponse); // 转换逻辑
            }

            private SDKPaymentRequest convertToSdkRequest(PaymentCommand command) { /* ... */ return new SDKPaymentRequest(); }
            private PaymentResult convertToPaymentResult(SDKPaymentResponse sdkResponse) { /* ... */ return new PaymentResult(); }
        }
        ```

#### 2. 装饰器模式 (Decorator)
*   **意图**：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
*   **应用场景**：
    *   当你希望在无需修改代码夜空动态地向对象添加功能， 且不影响同类型的其他对象时。
    *   当通过子类扩展不切实际或不可能时，例如由于子类的数量会呈爆炸性增长，或者类定义被隐藏或无法访问。
    *   Java IO库中的 `BufferedInputStream(InputStream)` 就是一个典型例子。
    *   在业务逻辑中，例如为某个基础服务添加缓存、日志、权限校验等功能，可以通过装饰器实现，但Spring AOP通常是更方便的选择。

#### 3. 策略模式 (Strategy)
*   **意图**：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
*   **应用场景**：
    *   当你有许多仅在行为上有所不同的相关类时。
    *   当你需要使用一个算法的不同变体时。
    *   当你希望在运行时根据具体情况选择算法时。
    *   在DDD中，如果一个实体或领域服务有多种处理方式（例如，订单有多种优惠计算策略、用户有多种通知发送策略），策略模式非常适用。
    *   **示例（订单优惠计算）**：
        ```java
        // 策略接口
        public interface DiscountStrategy {
            Money applyDiscount(Order order, Money currentTotal);
        }

        // 具体策略实现
        @Component("滿减策略")
        public class FixedAmountDiscountStrategy implements DiscountStrategy {
            @Override
            public Money applyDiscount(Order order, Money currentTotal) {
                if (currentTotal.isGreaterThan(new Money(100, Currency.CNY))) {
                    return currentTotal.subtract(new Money(10, Currency.CNY));
                }
                return currentTotal;
            }
        }
        @Component("折扣策略")
        public class PercentageDiscountStrategy implements DiscountStrategy {
            private final BigDecimal discountRate = new BigDecimal("0.9"); // 9折
            @Override
            public Money applyDiscount(Order order, Money currentTotal) {
                return currentTotal.multiply(discountRate);
            }
        }

        // 使用策略的领域服务或应用服务
        @Service
        public class OrderPricingService {
            private final Map<String, DiscountStrategy> discountStrategies; // 注入所有策略

            @Autowired
            public OrderPricingService(List<DiscountStrategy> strategies) {
                this.discountStrategies = strategies.stream()
                    .collect(Collectors.toMap(
                        s -> s.getClass().getAnnotation(Component.class).value(), // 或者其他方式获取策略名称
                        s -> s
                    ));
            }

            public Money calculateFinalPrice(Order order, String selectedStrategyName) {
                DiscountStrategy strategy = discountStrategies.get(selectedStrategyName);
                if (strategy == null) {
                    throw new IllegalArgumentException("Unsupported discount strategy: " + selectedStrategyName);
                }
                // 假设order.calculateProvisionalTotal() 返回一个Money对象
                return strategy.applyDiscount(order, order.calculateProvisionalTotal());
            }
        }
        ```

#### 4. 模板方法模式 (Template Method)
*   **意图**：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
*   **应用场景**：
    *   当你想让客户端只扩展算法的特定步骤， 而不是整个算法或其结构时。
    *   当多个类中包含相似的算法， 但其部分步骤有所不同， 你希望避免代码重复时。
    *   例如，通用的数据处理流程，其中数据读取、解析、校验、存储等步骤是固定的，但具体实现可能不同。`BaseRpcService` 中的 `rpcResult` 或 `parseResult` 方法可以看作是模板方法的应用。
    *   **示例（通用数据导入流程）**：
        ```java
        public abstract class AbstractDataImporter {
            // 模板方法
            public final void importData(String filePath) {
                DataSource source = openSource(filePath);
                List<RawData> rawItems = readData(source);
                List<ValidatedData> validatedItems = validateData(rawItems);
                List<DomainObject> domainObjects = convertToDomainObjects(validatedItems);
                saveDomainObjects(domainObjects);
                closeSource(source);
                postImportHook(domainObjects.size());
            }

            // 抽象方法，由子类实现
            protected abstract DataSource openSource(String path);
            protected abstract List<RawData> readData(DataSource source);
            protected abstract List<ValidatedData> validateData(List<RawData> rawItems);
            protected abstract List<DomainObject> convertToDomainObjects(List<ValidatedData> validatedItems);
            protected abstract void saveDomainObjects(List<DomainObject> domainObjects);
            protected abstract void closeSource(DataSource source);
            
            // 钩子方法，子类可选择性覆盖
            protected void postImportHook(int itemCount) {
                log.info("{} items imported successfully.", itemCount);
            }
        }

        // 具体实现类
        public class UserCsvImporter extends AbstractDataImporter {
            // ... 实现所有抽象方法 ...
            @Override
            protected List<RawData> readData(DataSource source) {
                // CSV specific reading logic
                return Collections.emptyList();
            }
            // ...
        }
        ```

### 2.3 行为型模式

#### 1. 责任链模式 (Chain of Responsibility)
*   **意图**：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
*   **应用场景**：
    *   当你的程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时。
    *   当你需要依次运行多个处理器， 或在运行时确定顺序时。
    *   例如，审批流程、过滤器链（Servlet Filters, Spring Interceptors）、复杂的优惠券叠加规则。
    *   **示例（优惠券处理链）**：
        ```java
        // 处理者接口
        public abstract class CouponHandler {
            protected CouponHandler nextHandler;

            public void setNextHandler(CouponHandler nextHandler) {
                this.nextHandler = nextHandler;
            }

            public abstract void apply(OrderContext orderContext);
        }

        // 具体处理者
        public class ProductDiscountCouponHandler extends CouponHandler {
            @Override
            public void apply(OrderContext orderContext) {
                if (canHandle(orderContext.getCurrentCoupon())) {
                    // 应用商品折扣券逻辑
                    orderContext.addAppliedDiscount("Product Discount Applied");
                }
                if (nextHandler != null) {
                    nextHandler.apply(orderContext);
                }
            }
            private boolean canHandle(Coupon coupon) { return coupon.getType() == CouponType.PRODUCT_DISCOUNT; }
        }

        public class ShippingFeeCouponHandler extends CouponHandler {
            @Override
            public void apply(OrderContext orderContext) {
                if (canHandle(orderContext.getCurrentCoupon())) {
                    // 应用运费券逻辑
                    orderContext.addAppliedDiscount("Shipping Fee Waived");
                }
                if (nextHandler != null) {
                    nextHandler.apply(orderContext);
                }
            }
             private boolean canHandle(Coupon coupon) { return coupon.getType() == CouponType.SHIPPING_FEE; }
        }
        
        // OrderContext.java (持有订单信息和当前处理状态)
        // Coupon.java (优惠券信息)
        // CouponType.java (枚举)

        // 使用
        // CouponHandler productHandler = new ProductDiscountCouponHandler();
        // CouponHandler shippingHandler = new ShippingFeeCouponHandler();
        // productHandler.setNextHandler(shippingHandler);
        // productHandler.apply(orderContext); // 传入包含待处理优惠券的订单上下文
        ```

#### 2. 观察者模式 (Observer)
*   **意图**：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
*   **应用场景**：
    *   当一个对象的改变需要同时改变其他对象， 而不知道具体有多少对象有待改变。
    *   当一个对象必须通知其他对象， 但它又不能对这些对象做出任何假设。换言之， 你不希望这些对象是紧密耦合的。
    *   在DDD中，**领域事件 (Domain Event)** 的发布与订阅机制是观察者模式的典型应用。当聚合根状态发生重要变化时，可以发布一个领域事件，其他关心此事件的限界上下文或模块可以订阅并处理。
    *   Spring框架提供了 `ApplicationEventPublisher` 和 `@EventListener` 来简化事件处理。
    *   **示例（订单支付成功事件）**：
        ```java
        // 领域事件 (POJO)
        @Getter
        public class OrderPaidEvent extends ApplicationEvent {
            private final Long orderId;
            private final Money amountPaid;

            public OrderPaidEvent(Object source, Long orderId, Money amountPaid) {
                super(source);
                this.orderId = orderId;
                this.amountPaid = amountPaid;
            }
        }

        // 事件发布方 (通常在应用服务或领域实体方法中)
        @Service
        public class OrderApplicationService {
            private final ApplicationEventPublisher eventPublisher;
            // ...
            @Autowired
            public OrderApplicationService(ApplicationEventPublisher eventPublisher /*...other deps */) {
                this.eventPublisher = eventPublisher;
            }

            @Transactional
            public void confirmOrderPayment(Long orderId, Money paymentAmount) {
                Order order = orderRepository.findById(orderId);
                order.confirmPayment(paymentAmount); // 实体行为
                orderRepository.save(order);

                // 发布领域事件
                eventPublisher.publishEvent(new OrderPaidEvent(this, orderId, paymentAmount));
                log.info("OrderPaidEvent published for orderId: {}", orderId);
            }
        }

        // 事件监听器/订阅方 (可以有多个，处理不同后续逻辑)
        @Component
        public class NotificationService {
            @EventListener
            public void handleOrderPaidEvent(OrderPaidEvent event) {
                log.info("Received OrderPaidEvent for order {}. Sending payment confirmation notification...", event.getOrderId());
                // 发送通知逻辑
            }
        }

        @Component
        public class InventoryService {
            @EventListener
            public void handleOrderPaidEventForInventory(OrderPaidEvent event) {
                log.info("Received OrderPaidEvent for order {}. Updating inventory...", event.getOrderId());
                // 更新库存逻辑
            }
        }
        ```

#### 3. 状态模式 (State)
*   **意图**：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
*   **应用场景**：
    *   当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时。
    *   当一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态时。通常，状态模式建议将每个分支放入独立的类中。
    *   在DDD中，如果一个实体有复杂的生命周期和状态转换，且不同状态下行为差异显著，可以使用状态模式。
    *   例如，订单状态（待支付、已支付、已发货、已完成、已取消）及其对应的操作。
    *   **示例（订单状态机）**：
        ```java
        // 状态接口
        public interface OrderState {
            void pay(OrderContext order);       // 支付
            void ship(OrderContext order);      // 发货
            void confirmReceipt(OrderContext order); // 确认收货
            void cancel(OrderContext order);    // 取消
            OrderStatus getStatus();
        }

        // 具体状态类
        public class PendingPaymentState implements OrderState {
            @Override
            public void pay(OrderContext order) {
                System.out.println("Order paid. Changing state to PROCESSING.");
                order.changeState(new ProcessingState());
                // 实际应用中会调用order.setPaymentDetails()等
            }
            @Override public void ship(OrderContext order) { throw new IllegalStateException("Cannot ship an unpaid order."); }
            @Override public void confirmReceipt(OrderContext order) { throw new IllegalStateException("Cannot confirm receipt for an unpaid order."); }
            @Override public void cancel(OrderContext order) { /* ... */ order.changeState(new CancelledState()); }
            @Override public OrderStatus getStatus() { return OrderStatus.PENDING_PAYMENT; }
        }
        // ProcessingState, ShippedState, CompletedState, CancelledState ...

        // 上下文类 (通常是领域实体 Order)
        public class OrderContext { // 在DDD中这通常是 Order 实体自身
            private OrderState currentState;
            private Long id;
            // ... 其他订单属性

            public OrderContext(Long id) {
                this.id = id;
                this.currentState = new PendingPaymentState(); // 初始状态
            }

            public void changeState(OrderState newState) {
                this.currentState = newState;
                // 持久化状态变更，发布领域事件等
                System.out.println("Order " + id + " state changed to: " + newState.getStatus());
            }

            public void pay() { currentState.pay(this); }
            public void ship() { currentState.ship(this); }
            public void confirmReceipt() { currentState.confirmReceipt(this); }
            public void cancel() { currentState.cancel(this); }
            public OrderStatus getCurrentStatus() { return currentState.getStatus(); }
        }

        // OrderStatus.java (枚举: PENDING_PAYMENT, PROCESSING, SHIPPED, COMPLETED, CANCELLED)
        ```

## 三、Mermaid图示在设计文档中的应用

根据 `@tech-solution-doc-spec.mdc` 的要求，所有技术方案中的架构图、流程图、时序图、状态图、类图、ER图等，均推荐使用 Mermaid 语法绘制。

*   **流程图 (`graph TD` 或 `flowchart TD`)**: 描述业务流程、决策逻辑。
*   **时序图 (`sequenceDiagram`)**: 展示对象间的交互和消息顺序，非常适合描述API调用、模块协作。
*   **状态图 (`stateDiagram-v2`)**: 描述对象生命周期中的状态及转换，契合状态模式。
*   **类图 (`classDiagram`)**: 展示类及其关系，适合描绘设计模式的结构或领域模型。
*   **ER图 (`erDiagram`)**: 数据库设计。

在应用设计模式时，通过Mermaid绘制相应的类图或时序图，可以非常清晰地表达模式的结构和参与者之间的协作关系，有助于团队理解和评审。

**例如，策略模式的类图：**
```mermaid
classDiagram
    OrderPricingService ..> DiscountStrategy : uses
    DiscountStrategy <|.. FixedAmountDiscountStrategy
    DiscountStrategy <|.. PercentageDiscountStrategy
    class OrderPricingService {
        +calculateFinalPrice(Order order, String strategyName) Money
    }
    class DiscountStrategy {
        <<Interface>>
        +applyDiscount(Order order, Money currentTotal) Money
    }
    class FixedAmountDiscountStrategy {
        +applyDiscount(Order order, Money currentTotal) Money
    }
    class PercentageDiscountStrategy {
        +applyDiscount(Order order, Money currentTotal) Money
    }
```

## 四、AI辅助设计模式应用与规范检查

1.  **模式识别与推荐**：
    *   向AI描述遇到的设计问题或代码中的"坏味道"（如大量if-else判断状态、对象创建复杂等），询问是否有适用的设计模式。
    *   例如："我有一个方法，根据用户的不同类型执行不同的计算逻辑，目前用了大量if-else，有什么设计模式可以优化吗？" (AI可能推荐策略模式或工厂模式)。
2.  **模式结构生成**：
    *   一旦确定使用某种设计模式，可以要求AI生成该模式的基本结构代码（接口、抽象类、具体实现类骨架），并遵循 `@yupao-code-development-and-quality.mdc` 的命名和注释规范。
3.  **场景适配分析**：
    *   与AI讨论特定设计模式在当前业务场景下的优缺点、适用性以及可能遇到的问题。
4.  **规范符合性检查**：
    *   提供一段应用了某种设计模式的代码，询问其是否符合本设计模式指南 (`@yupao-design-patterns.mdc`) 的推荐做法，或者是否遵循了相关的SOLID原则。
5.  **Mermaid图表辅助**：
    *   描述了设计模式的参与者和关系后，可以请求AI生成对应的Mermaid类图或时序图草稿。

---
*本指南将根据项目实践和团队反馈持续更新。*