---
description: 
globs: 
alwaysApply: true
---
# Java项目HTTP API规范

本规则基于现有项目规范，专注于HTTP接口的设计规范。

## HTTP接口规范

### 【强制】接口URL格式
1. 基本格式：`http://xxx-develop.xxx.com/{大业务领域}/{版本或网络标识}/{子领域}/{模块}/{具体操作}` (例如: `/v1/` 或 `/app/`)
2. 版本号格式：v1, v2, v3等 (用于路径中的版本标识)
3. 网络类型 (用于路径中的网络标识，若与版本号同时使用，团队需统一路径组合方式，例如 `/v1/app/` 或约定只使用其一)：
   - app：移动端接口
   - web：Web端接口
   - mini：小程序接口
   - intranet：内网接口
4. URL必须全小写，单词间用中划线"-"分隔。
5. URL路径应清晰表达资源和操作意图，即使所有请求均为POST，路径本身也应具有可读性，以区分不同业务操作。

### 【强制】请求方法规范
1.  **所有HTTP API接口必须统一使用POST方法。**
2.  **操作意图区分**：
    *   业务操作的具体类型（如创建、查询、更新、删除、特定业务动作等）必须通过以下一种或组合方式在POST请求中明确：
        *   **URL路径（推荐首选）**：接口的URL路径应尽可能清晰地描述其操作的资源和意图。例如，`POST /user/create`，`POST /user/get-by-id`，`POST /order/update-status`。
        *   **请求体参数**：可以在POST请求的JSON Body中包含一个明确的字段（如 `action` 或 `operationType`）来指定具体操作。此方式应谨慎使用，主要用于同一资源有多个高度相关的次要操作，以避免URL路径过多。例如：
            ```json
            // POST /user/manage
            {
              "action": "getUserDetails", // 或 "createUser", "updateProfile"
              "userId": "123",
              // ...其他参数
            }
            ```
            （注意：此方式下URL可能更通用，如 `/user/manage`，具体操作依赖`action`字段。需谨慎设计以避免URL过于宽泛导致职责不明。）
3.  **参数传递**：所有请求参数，包括传统上通过URL Query String传递的参数（如分页参数、查询条件、标识符等），都必须通过POST请求的Request Body以JSON格式传递。
4.  **幂等性**：虽然所有请求都使用POST，但对于本质上是幂等的操作（如根据唯一ID更新资源、删除资源），服务端实现时仍需保证其幂等性。客户端在需要时（如网络超时后重试）可以安全地重发这些POST请求。非幂等操作（如不带唯一标识的创建）不应设计为可安全重试。
5.  **缓存**：统一使用POST请求后，标准的HTTP GET缓存机制将不再适用。如需缓存，应在应用层面或通过其他服务端缓存策略实现。

### 【强制】接口命名规范 (所有操作均使用POST)
*   接口URL路径应清晰描述其功能，即使方法统一为POST。
*   建议在URL路径中包含动词或能表明操作类型的词语，以增强可读性。

1. 新增接口 (POST)：
   ```
   POST /ums/v1/employee/add              // 外网单个新增
   POST /ums/v1/employee/batch-add        // 外网批量新增
   POST /ums/intranet/employee/add        // 内网单个新增
   POST /ums/intranet/employee/batch-add  // 内网批量新增
   ```

2. 修改接口 (POST)：
   ```
   POST /ums/v1/employee/update                // 按主键修改
   POST /ums/v1/employee/batch-update          // 按主键批量修改
   POST /ums/v1/employee/update-by-tel         // 按手机号修改
   POST /ums/v1/employee/update-by-condition   // 按条件修改
   ```

3. 删除接口 (POST)：
   ```
   POST /ums/v1/employee/delete                // 按主键删除
   POST /ums/v1/employee/batch-delete          // 按主键批量删除
   POST /ums/v1/employee/delete-by-tel         // 按手机号删除
   POST /ums/v1/employee/delete-by-condition   // 按条件删除
   ```

4. 查询接口 (POST)：
   ```
   POST /ums/v1/employee/get-by-id             // 主键查询 (参数在请求体中)
   POST /ums/v1/employee/get-by-tel            // 手机号查询 (参数在请求体中)
   POST /ums/v1/employee/page-query            // 分页查询 (分页参数在请求体中)
   POST /ums/v1/employee/list-query            // 列表查询 (查询参数在请求体中)
   ```

### 【强制】请求参数规范
1.  **所有请求参数必须通过POST请求的Request Body以JSON格式传递。**
2.  分页参数 (示例，作为JSON请求体的一部分):
    ```java
    // 请求对象示例: UserPageReq.java
    // import com.hexonal.commons.base.BaseQueryReq; // 如果还适用

    public class UserPageReq /* extends BaseQueryReq */ {
        @Min(1)
        private Integer pageNum = 1;    // 页码，从1开始
        
        @Min(1) @Max(100) // 建议最大值也通过配置管理
        private Integer pageSize = 10;  // 每页大小，默认10
        
        // ...其他查询条件字段...
        private String nameQuery;
        private Integer statusQuery;

        // 【推荐】排序参数
        private String sortBy;      // 排序字段 (例如：createdAt)
        private String sortDirection; // 排序方向 (ASC 或 DESC)
    }
    ```
    请求体JSON示例:
    ```json
    {
        "pageNum": 1,
        "pageSize": 20,
        "nameQuery": "张三",
        "statusQuery": 1,
        "sortBy": "createdAt",
        "sortDirection": "DESC"
    }
    ```

3.  时间参数：
    *   请求（在JSON Body中）：使用时间戳（毫秒）或ISO8601格式字符串（如 `"2023-10-26T10:30:00.000Z"`）。推荐使用ISO8601以增强可读性。
    *   响应：统一使用ISO8601格式（`yyyy-MM-dd'T'HH:mm:ss.SSSZ`）。

4.  枚举参数（在JSON Body中）：
    *   建议传递枚举的名称（字符串）或约定的代码值（整数/字符串）。如果传递代码值，需确保接口文档清晰说明。
    ```java
    // 服务端定义
    public enum OrderStatus {
        UNPAID(0, "未支付"),
        PAID(1, "已支付"),
        CANCELLED(-1, "已取消");
        // ...
    }
    // 请求体JSON示例 (传递名称)
    // { "orderStatus": "PAID" }
    // 或请求体JSON示例 (传递代码值)
    // { "orderStatus": 1 }
    ```

### 【强制】响应规范
1.  分页响应：**必须统一使用**在 `@java-error-handling-and-operations.mdc` 中定义的 `Result<T>` 结构。其中 `T` 为分页数据结构，例如 `PageData<ItemType>`，该 `PageData` 应包含列表 (`list`)、总记录数 (`totalCount` 或 `totalRecords`)、当前页码 (`pageNum`)、每页大小 (`pageSize`)。
    ```java
    // 示例 PageData 结构 (应在公共模块定义)
    // public class PageData<T> {
    //     private List<T> list;
    //     private long totalRecords;
    //     private int pageNum;
    //     private int pageSize;
    //     // 构造器、getter、setter
    // }
    // Result<PageData<UserPageResp>>
    ```
    所有响应数据，包括分页结果，都包装在统一的 `Result<T>` 响应体内。

### 【强制】接口文档规范 (所有请求均为POST)
1.  Swagger (OpenAPI) 注解示例：
    *   所有操作（`@ApiOperation`）均对应 `@PostMapping` 注解。
    *   参数描述 (`@ApiImplicitParam`, 或通过请求体DTO的 `@ApiModelProperty`) 必须明确参数是在Request Body中。
    ```java
    @Api(tags = "用户管理")
    @RestController
    @RequestMapping("/api/v1/users") // 基础路径
    public class UserController {
        
        @ApiOperation(value = "创建用户", notes = "通过POST请求创建新用户并返回用户信息")
        @PostMapping("/create") // 具体操作路径
        public Result<UserResp> createUser(@RequestBody @Valid UserCreateReq userCreateReq) {
            // 实现代码，UserCreateReq 包含创建用户所需参数
            // 返回 Result<UserResp>
        }

        @ApiOperation(value = "查询用户分页列表", notes = "通过POST请求分页查询用户信息")
        @PostMapping("/page-query") // 具体操作路径
        public Result<PageResult<UserPageResp>> pageUser(@RequestBody @Valid UserPageQueryReq userPageQueryReq) {
            // 实现代码，UserPageQueryReq 包含分页参数及查询条件
            // 返回 Result<PageResult<UserPageResp>>
        }
    }
    ```

2.  必须包含以下内容：
    *   接口功能描述。
    *   **POST请求体JSON结构详细说明**（包括所有参数的名称、类型、是否必填、含义、示例值、校验规则如 JSR303 注解）。
    *   响应体JSON结构详细说明（包括 `Result<T>` 包装结构和内部数据 `T` 的结构）。
    *   错误码说明 (参考 `@java-error-handling-and-operations.mdc`，并列出本接口可能返回的具体业务错误码)。
    *   完整的请求和响应示例JSON (覆盖成功和常见失败场景)。
    *   **【推荐】**清晰说明接口的幂等性行为，以及（如果支持）客户端应如何传递幂等性令牌。
    *   **【推荐】**对于废弃的接口或版本，使用 `@Deprecated` 注解，并在文档中明确说明废弃原因、替代接口及计划移除时间。

---
**附注：**
*   所有API的实现必须严格遵守 `@java-error-handling-and-operations.mdc` 中定义的错误处理、日志记录和安全规范。
*   对于需要保证幂等性的重要操作（特别是创建类操作，以防客户端重试导致重复创建），应考虑支持客户端传递幂等性令牌（例如，在请求头或请求体中包含 `X-Request-Id` 或 `Idempotency-Key`），服务端进行相应处理。
*   批量操作的请求体和响应体结构应有明确规范，例如请求为一个JSON数组，响应体能区分各条记录的处理成功与失败详情。