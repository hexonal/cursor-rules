---
description: 
globs: 
alwaysApply: true
---
# Java项目数据持久化规范

本规则基于阿里巴巴Java开发手册和现有项目规范，专注于数据库设计、SQL开发和ORM使用等方面的最佳实践。

## 一、表结构规范

### 【强制】基础字段
每个表必须包含以下基本字段：

| 字段名 | 字段含义 | 字段类型 | 默认值 | 备注 |
|--------|----------|----------|--------|------|
| id | 数据库自增主键 | bigint | 无 | 对于可以预见数量在千万级以下的，可以使用int，否则使用bigint |
| created_at | 记录创建时间 | datetime | NOW() | 创建后不允许修改 |
| created_by | 记录创建人 | varchar(100) | "" | 创建后不允许修改；长度可以根据业务做调整。推荐使用varchar以适应不同长度的用户标识。 |
| updated_at | 记录更新时间 | datetime | NOW() | 每次业务导致的修改，需要修改该字段 |
| updated_by | 记录更新操作人 | varchar(100) | "" | 每次业务导致的修改，需要修改该字段；长度可以根据业务做调整。推荐使用varchar以适应不同长度的用户标识。 |
| deleted | 逻辑删除 | tinyint(1) | 0 | 0: 未删除，1：已删除。查询时通常应附带 WHERE deleted = 0 条件。 |

示例建表语句：
```sql
CREATE TABLE `xxx` (
    `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
    `name` char(16) NOT NULL ,
    ## 业务字段
    `created_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `created_by` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '创建人',
    `updated_at` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
    `updated_by` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '创建人',
    `deleted` tinyint(1) DEFAULT '0' COMMENT '删除状态 0-未删除 1-已删除',
    PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=DYNAMIC;
```

### 【强制】索引命名规范

| 索引类型 | 命名规则 | 示例 |
|----------|----------|------|
| 普通索引 | idx_{索引字段} | 在im_group_id字段上加普通索引，索引名称为：idx_im_group_id |
| 唯一索引 | uk_{索引字段} | 在order_id字段上加唯一索引，索引名称为：uk_order_Id |
| 联合索引 | uni_{索引字段}_{索引字段}_{索引字段} | 在promote_time, start_time, deleted三个字段上添加联合索引，索引名称为uni_promote_time_start_time_deleted |

### 【强制】字段设计规范
1. 必须使用 UNSIGNED 存储非负数
2. 必须使用 TINYINT 存储布尔值（1是，0否）
3. 金额必须使用 DECIMAL，禁止使用 FLOAT 和 DOUBLE
4. 字符串长度不固定的用 VARCHAR，固定长度的用 CHAR (注意：CHAR类型会用空格补足长度，通常VARCHAR更常用)
5. 字段必须有明确的业务含义
6. 必须指定字段的字符集和排序规则
7. **【推荐】**对于业务上表示枚举的字段，推荐使用TINYINT或SMALLINT存储，并在代码中通过枚举类进行映射，确保数据一致性和易读性。

### 【强制】索引设计规范
1. 每个表必须有主键，推荐使用 BIGINT 自增
2. 常用查询字段必须建立索引
3. 更新频繁的字段不建议建立索引
4. 索引个数不超过5个
5. 联合索引需要考虑最左前缀原则
6. **【推荐】**对于包含逻辑删除字段（如 `deleted`）的表，考虑在常用查询条件的联合索引中包含该字段，例如 `uni_some_field_deleted (some_field, deleted)`。
7. **【推荐】**索引设计应参考Repository层定义的数据访问模式，确保为领域对象的常见查询路径提供高效索引支持。

## 二、MyBatis 使用规范

### 【强制】Mapper 接口规范
1. 必须在 dao 模块下
2. 接口名必须以 Mapper 结尾
3. 方法名要见名知意
4. 参数超过2个必须使用 @Param 注解

### 【强制】XML 文件规范
1. 必须在 resources/mapper 目录下
2. 路径必须与接口包路径一致 (namespace也必须与Mapper接口的完全限定名一致)
3. 必须指定 resultType 或 resultMap (推荐使用resultMap处理复杂映射和关联查询，尽管关联查询应谨慎使用，优先通过多次单表查询由应用层组装)
4. 禁止使用 * 查询所有字段
5. 必须注明 SQL 的用途和作者

### 【强制】SQL 开发规范
1. 禁止使用存储过程
2. 禁止使用 SELECT * (即使在子查询中也应避免)
3. 禁止使用 ORDER BY RAND()
4. 必须使用 #{} 预编译，禁止使用 ${} (除非是动态表名、列名等特殊且受控场景，并有严格校验)
5. 必须有注释说明 SQL 的用途
6. **【推荐】**谨慎使用MyBatis的动态SQL（如 `<if>`, `<foreach>`），确保其逻辑清晰、易于测试且不引入SQL注入风险。复杂业务判断应在Java领域层处理。

## 三、性能优化规范

### 【强制】查询优化
1. 必须有查询条件
2. 必须限制查询记录数 (使用LIMIT)
3. 禁止使用 SELECT COUNT(*) (如需计数，推荐使用 `SELECT COUNT(1)` 或 `SELECT COUNT(主键)`)
4. 分页必须使用 LIMIT
5. 大数据量查询必须使用分页
6. **【推荐】**针对高频查询考虑使用覆盖索引（Covering Index）以减少回表。

### 【强制】更新优化
1. 必须带有 WHERE 条件
2. 禁止使用 UPDATE TABLE SET col=1 (无WHERE条件的全表更新)
3. 必须使用乐观锁进行并发控制 (推荐使用 version 字段，`BIGINT` 类型，每次更新时 version = version + 1)
4. 批量更新必须限制数量
5. 必须在事务中执行

### 【强制】连接池配置
1. 必须使用 Druid 连接池
2. 必须配置以下参数：
   ```yaml
   initialSize: 5
   minIdle: 5
   maxActive: 20
   maxWait: 60000
   timeBetweenEvictionRunsMillis: 60000
   minEvictableIdleTimeMillis: 300000
   validationQuery: SELECT 1
   testWhileIdle: true
   testOnBorrow: false
   testOnReturn: false
   poolPreparedStatements: true
   maxPoolPreparedStatementPerConnectionSize: 20
   filters: stat,wall,slf4j
   ```